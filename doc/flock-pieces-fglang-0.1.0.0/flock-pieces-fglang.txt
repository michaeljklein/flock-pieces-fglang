-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package flock-pieces-fglang
@version 0.1.0.0

module Data.Functor.Join

-- | An isomorphism, as in:
--   <a>https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Iso.html</a>
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)

-- | An isomorphism, specialized to two types
type Iso' s a = Iso s s a a

-- | Join two functors together
class (Functor f, Functor g) => Join f g
partition :: Join f g => Iso' (f (g a)) (f (f (g a)))
pushover :: Join f g => Iso' (f (f (g a))) (f (g (f a)))
push :: Join f g => Iso' (f (g a)) (f (g (f a)))

-- | Join left

-- | Join right

-- | Three types of join: left, right, and done
data JoinTypes
JoinL :: JoinTypes
JoinR :: JoinTypes
Joined :: JoinTypes

-- | <a>undefined</a>
joinL :: f (f a) -> f a

-- | <a>undefined</a>
joinR :: Join f g => f (g (f a)) -> f (g a)

-- | Simple wrapper
newtype F f a
F :: f a -> F f a
[getF] :: F f a -> f a

-- | Simple wrapper
newtype G g a
G :: g a -> G g a
[getG] :: G g a -> g a

-- | The type of a join

-- | If <tt>f (g a))</tt> then return, else recurse

-- | If zero, return, else recurse

-- | Next iteration of <a>Joining</a>
class Joining' (JoinType a) (JoinType b) => Joining a b
joining :: Joining a b => a -> b

-- | Generic function typeclass, helper for <a>Joining</a>
class Joining' a b
joining' :: Joining' a b => a -> b

-- | Notes:
--   
--   <pre>
--   instance Joining' (F f (G g (F f a)))
--   
--   class JoinedC n m f g a b
--   
--   data Joined n m f g a = forall b. JoinedC n m f g a b. Joined b
--   
--   SomeJoined f g a { Joined n m f g a }
--   
--   Joined n m f g a -&gt; Joined n' m' f g a
--   </pre>

-- | Next iteration of <a>JoinType</a>

-- | For this attempt, the instances are still pretty far from compiling:
--   
--   <pre>
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinL JoinL where
--     joining'' x = joinL . joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinL JoinR where
--     joining'' x = joinL . joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinL Joined where
--     joining'' x = joinL . joining'' x
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinR JoinL where
--     joining'' x = joinR . joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinR JoinR where
--     joining'' x = joinR . joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinR Joined where
--     joining'' x = joinR . joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b Joined JoinL where
--     joining'' x =         joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b Joined JoinR where
--     joining'' x =         joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b Joined Joined where
--     joining'' x = id
--   </pre>
class (JointL a ~ JointL b, JointR a ~ JointR b, Join (JointL a) (JointR b), JoinType''' a ~ joinTypeA, JoinType''' b ~ joinTypeB) => Joining'' a b (joinTypeA :: JoinTypes) (joinTypeB :: JoinTypes)
joining'' :: Joining'' a b joinTypeA joinTypeB => a -> b
instance GHC.Show.Show Data.Functor.Join.JoinTypes
instance GHC.Classes.Ord Data.Functor.Join.JoinTypes
instance GHC.Classes.Eq Data.Functor.Join.JoinTypes
instance (GHC.Base.Functor f, Data.Functor.Join.Joining' (Data.Functor.Join.F f a) (Data.Functor.Join.F f b)) => Data.Functor.Join.Joining' (Data.Functor.Join.F f (Data.Functor.Join.F f a)) (Data.Functor.Join.F f (Data.Functor.Join.F f b))
instance GHC.Base.Functor g => GHC.Base.Functor (Data.Functor.Join.G g)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Join.F f)

module Data.Functor.Turn

-- | A <a>Functor</a> <a>Turn</a>ing class..
--   
--   Ideas for implementing this language as a Haskell class:
--   
--   <pre>
--   givenExpression :: f (g a)
--   rturn ::        any (g a) <a>-</a> any (g (f a))
--   rturn :: C h =&gt; h   (g a) <a>-</a> h   (g (f a))
--   
--   lturn ::        any a <a>-</a> f (any a)
--   lturn :: C h =&gt; h   a  -&gt; f (h   a)
--   </pre>
--   
--   <pre>
--   class C f g where
--     base0 :: Turn f g (Compose f g) =&gt; ()
--     base1 :: Turn f g (Compose f (Compose g f)) =&gt; ()
--   
--     lturnWitness :: (Turn f g h =&gt; ()) -&gt; (Turn f g (Compose f h) =&gt; ())
--   
--   instance C (Base f g)
--   instance C (Compose h g) =&gt; C (Compose h (Compose g f))
--   instance C h =&gt; C (Compose f h)
--   </pre>
class Turn f g h | h -> f, h -> g

-- | Turn left
lturn :: Turn f g h => h a -> f (h a)

-- | Turn right
rturn :: Turn f g h => h (g a) -> h (g (f a))

-- | categorical dual of Turn
class Coturn f g h | h -> f, h -> g

-- | Co-Turn left
clturn :: Coturn f g h => f (h a) -> h a

-- | Co-Turn right
crturn :: Coturn f g h => h (g (f a)) -> h (g a)

-- | The free implementation of a "freely turning" data type
data FreeTurn f g a
[FreeLTurn] :: f (FreeTurn f g a) -> FreeTurn f g a
[FreeRTurn] :: FreeTurn f g (g a) -> FreeTurn f g (g (f a))

-- | Can we prove that <tt>(lturn (FreeRTurn x))</tt> is a type error?
--   
--   <pre>
--   FreeRTurn x :: FreeTurn f g (g (f a))
--   lturn       :: FreeTurn f g       a   -&gt; f (FreeTurn f g a)
--   
--   Thus g (f a) ~ a, a type error in standard haskell
--   </pre>
--   
--   Q.E.D.

-- | Free <a>Coturn</a>
data FreeCoturn f g a
[FreeLcoturn] :: f (FreeCoturn f g a) -> FreeCoturn f g a
[FreeRcoturn] :: FreeCoturn f g (g (f a)) -> FreeCoturn f g (g a)

-- | This one is easy

-- | Left and right turning data structure
data Turning f g a
[LTurn] :: f (Turning f g a) -> Turning f g a
[RTurn] :: Turning f g (g a) -> Turning f g (g (f a))
[RCoturn] :: Turning f g (g (f a)) -> Turning f g (g a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Turn.Turning f g)
instance Data.Functor.Turn.Turn f g (Data.Functor.Turn.Turning f g)
instance Data.Functor.Turn.Coturn f g (Data.Functor.Turn.Turning f g)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Turn.FreeCoturn f g)
instance Data.Functor.Turn.Coturn f g (Data.Functor.Turn.FreeCoturn f g)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Turn.FreeTurn f g)
instance Data.Functor.Turn.Turn f g (Data.Functor.Turn.FreeTurn f g)

module Data.Hashable.Orphans

-- | A left, strict fold using <a>hashWithSalt</a>

-- | Generate a random list, append a random value, and ensure their hashes
--   are different
testHashableSeq :: (Eq a, Hashable a) => a -> [a] -> Bool

-- | <tt>quickCheck</tt> <a>testHashableSeq</a>
prop_testHashableSeq :: Int -> [Int] -> Bool
quickCheckHashableSeq :: IO Bool
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Sequence.Internal.Seq a)

module Data.Tuple.Utils

-- | Apply a function to the first of a triple
first3 :: (a -> b) -> (a, c, d) -> (b, c, d)

-- | Get the first element of a triple
fst3 :: (a, b, c) -> a

-- | Get the second element of a triple
snd3 :: (a, b, c) -> b

-- | Get the third element of a triple
trd3 :: (a, b, c) -> c

module Data.HashSet.Utils

-- | Convenience synonym
type Set = HashSet

-- | All splits of a sequence <tt>(initial, current, rest)</tt>
allSplits :: (Eq a, Hashable a) => Seq a -> Set (Seq a, a, Seq a)
prop_allSplitsLength :: [Int] -> Bool

-- | Each should be equal to the original, when put back together
prop_allSplitsAreSplits :: [Int] -> Bool
prop_allSplitsHaveExpectedLengths :: [Int] -> Bool

-- | All splits of a sequence <tt>(initial, rest)</tt>
allSplits_ :: (Eq a, Hashable a) => Seq a -> Set (Seq a, Seq a)

-- | <pre>
--   length seq == length set
--   </pre>
prop_allSplits_Length :: [Int] -> Bool

-- | Each should be equal to the original, when put back together
prop_allSplits_AreSplits :: [Int] -> Bool
prop_allSplits_HaveExpectedLengths :: [Int] -> Bool

-- | Convert to list and then flatten using the union of two sets
flattenSet :: (Eq a, Hashable a) => Set (Set a) -> Set a

-- | All splits of a sequence on another sequence
splitsOn :: (Eq a, Hashable a) => Seq a -> Seq a -> Set (Seq a, Seq a)

-- | All one-application replacements
replacements :: (Eq a, Hashable a) => Seq a -> Set (Seq a) -> Seq a -> Set (Seq a)
quickCheckHashSetUtils :: IO Bool


-- | We want: <a>Functor</a> isomorphisms between these compositions of
--   <tt>F</tt> and <tt>G</tt>:
--   
--   <pre>
--   F(G(A))    -- we have a composition of functors
--   F(F(G(A))) -- we partition the outer functor into pieces such that `unique partition (xs :: f (g a))` is true for our partition (if it exists, of course, that's where graph coloring comes in)
--   F(G(F(A))) -- we push the partition into the inner functor, resulting in the connected (f (g a)) pieces being joined along their partitions.
--   </pre>
--   
--   In other words, it pulls the partition up to <tt>F</tt>'s level while
--   pushing the structure of <tt>F</tt> down into <tt>G</tt>. The
--   structure of <tt>F</tt> is available to <tt>G</tt> in slices (local by
--   definition of the partition).
--   
--   Note: all of these operations are invertible since we have unique
--   partitions (though I think I'm missing some constraints?)
--   
--   Additionally, the functors which this works for are local functors and
--   computers _really_ like computational and data locality. Computational
--   locality makes stream and massively parallel processing a breeze (case
--   in point, the line-by-line parser I just wrote).
--   
--   <pre>
--   f :: X -&gt; Y =&gt; F(G(f)) :: F(G(X)) -&gt; F(G(Y))
--   </pre>
--   
--   That is, we want three natural transformations that are also
--   isomorphisms between those compositions:
--   
--   <pre>
--   X :: C =&gt; eta_1(X) :: F(G(X)) -&gt; F(F(G(X))) :: C -&gt; C
--   X :: C =&gt; eta_2(X) :: F(F(G(X))) -&gt; F(G(F(X))) :: C -&gt; C
--   X :: C =&gt; eta_3(X) :: F(G(F(X))) -&gt; F(G(X)) :: C -&gt; C
--   
--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_1(Y) . F(G(f)) = F(F(G(f))) . eta_1(X) :: F(G(X)) -&gt; F(F(G(Y))) :: C -&gt; C
--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_2(Y) . F(F(G(f))) = F(G(F(f))) . eta_2(X) :: F(F(G(X))) -&gt; F(G(F(Y))) :: C -&gt; C
--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_3(Y) . F(G(F(f))) = F(G(f)) . eta_3(X) :: F(G(F(X))) -&gt; F(G(Y)) :: C -&gt; C
--   </pre>
--   
--   We require these natural transformations to be bijections.
--   
--   Misc. notes:
--   
--   <pre>
--   h = f . h
--   h -&gt; f . h
--   h . g -&gt; h . g . f
--   
--   f . h -&gt; h
--   h . g . f -&gt; h . g
--   </pre>
--   
--   <pre>
--   a pusher is guaranteed to push all it can over at once only if f is pointed and props hold.
--   
--   (i think) a copusher .. iff f is copointed and props hold
--   </pre>
--   
--   This effectively reduces <tt>(f+gf*)</tt> to <tt>(fgf?)</tt>. Is this
--   reduction a pushing of compositions of <tt>f</tt> inside?
--   
--   <pre>
--    yeah, what I've done is taken the set of words in the language, partitioned them on their compositions without all of the (return)'s, and given you a view inside that newly partitioned language.
--    Really, really cool. I think this means that the partition interpretation mught be precise.
--    ok, so let's say we have a partition (p), which is a natual transformation from (g a) to some index functor.
--      ahh, since p is an endofunctor, we only really need to have <tt>p</tt> be an injection, and can make the index functor `f (g a)`
--      really, we want the maximal (f (g a) -&gt; f (f (g a))) function such that pushing over pushes everything that can be over,
--      we want to partition on (g a) such that we can reconstruct the structure of a connected component of g's in the partition inside of (g a)
--   in other words, we need to ensure that the lines of the connected components do not cross the lines of what parts of <tt>f</tt> can be passed through <tt>g</tt>.
--     first of all, in what sense does <tt>f</tt> form a graph, that we can accurrately describe what parts are adjacent?
--       if <tt>f</tt> is pointed, then those components that cannot pass through are those such that: (push == fmap (fmap return) :: f . g -&gt; f . g . f)
--       so we get a relation `can pass through(To) :: f g (a)`, where push is non-trivial
--       we can also use (return) to specify that everything has passed through. we then can know: has anything passed through on <tt>x</tt> step, has everything passed through, really everything about what has passed through when
--       p  :: g a -&gt; b
--       p' :: f (g a) -&gt; b
--       p' (return x) = p x
--       extractor :: f b -&gt; maybe b
--       p' = extractor . fmap p
--       extractor (p <a>$</a> return x) = p x
--       ahh, we can have a natural extractor, y -&gt; { x | f associates x with y} :: f (g a) -&gt; {g a}
--       so we require that. y -&gt; forall (x :: g a). f x == y =&gt; p x :: f (g a) -&gt; Bool (the property maps all of the elements of the preimage to the same value)
--        and that holds forall (f (g a)) <a>elem</a> (f (f (g a)))
--        which also has a most general format of: y -&gt; { x | f associates x with y &amp;&amp; x <a>elem</a> y}
--        which I believe is both a valid inclusion and the most general inclusion
--        valid inclusion: (x <a>elem</a> return x), x <a>elem</a> y =&gt; forall f. f x <a>elem</a> fmap f y
--          if this is all we need then we get it from (x <a>elem</a> return x) and f being a functor [else hi]
--            (all singleton (== return x) preimages for <tt>f</tt> implies f == const | identity?)
--       and this predicate has: fmap pred . partition == fmap (const True) . partition
--       and the partition is preserved by crossing <tt>g</tt>?
--   </pre>
--   
--   Alright, we want to classify each operation as being idempotent, and
--   find what results we have.
--   
--   We already have that all being idempotent implies that <tt>f</tt> is
--   pointed and the second operation is equivalent to fmapping the
--   pointing function up to the difference in types.
--   
--   Since the category probably doesn't have bool (if that even makes
--   sense), if it's the unit category then the partition is trivial, else
--   it holds for mapping any pair of elements of C to (False, True)
--   
--   Really, it works either way, so we can just skip to it:
--   
--   <pre>
--   the checker does (if pred then xx else yy) and then we have:
--   fmap checker . partition == fmap (const xx) . partition
--   </pre>
--   
--   Question: is the <tt>checker</tt> function a valid function in the
--   category? I'm not sure. We may have to fall back to a fold.
module Data.FGLang

-- | Just <a>Bool</a>, tried making it its own data type
--   
--   <pre>
--   f . g     = f . f . g
--   f . f . g = f . g . f
--   f . g     = f . g . f
--   
--   (f . g) . f = (f . g . f) . f
--   </pre>
--   
--   <pre>
--   data Lang = F | G deriving (Eq, Ord, Show)
--   
--   FG = FFG = FGF
--   
--   instance Hashable Lang where
--     hashWithSalt = hashUsing (== F)
--   </pre>
type Lang = Bool

-- | An expression is a sqeuence of <a>Lang</a>s
newtype Expr
Expr :: Seq Lang -> Expr
[getExpr] :: Expr -> Seq Lang

-- | A left, strict fold using <a>hashWithSalt</a> instance Hashable Expr
--   where hashWithSalt salt = foldl' hashWithSalt salt . getExpr
--   
--   Generate a random list, append a random value, and ensure their hashes
--   are different
prop_HashableExpr :: Bool -> [Bool] -> Bool

-- | Parse an <a>Expr</a>.
--   
--   For example:
--   
--   <pre>
--   λ&gt; parse <a>GFGFGGFFGF</a>
--   fromList [True,False,True,False,True,True,False,False,True,False]
--   </pre>
parse :: String -> Expr

-- | Test whether all of the elements of a list are equal.
--   
--   Taken from: <tt>pieces<i>inhabited</i>src<i>Data</i>Expr.hs</tt>
allEq :: Eq a => [a] -> Bool

-- | Test that parsing a string of only F, G is equal to parsing that
--   string with a not-F,G string prepended, appended, resp.
prop_parseIgnoresAllButFG :: [Bool] -> String -> Bool

-- | Static test case: <tt>parse <a>FGHBVDERTYHBGVCDSER</a> == parse
--   <a>FGG</a></tt>
prop_parseIgnoresAllButFG' :: Bool

-- | First base
--   
--   <pre>
--   [F, G]
--   </pre>
base1 :: Expr
prop_r0_base1 :: Bool

-- | Second base
--   
--   <pre>
--   [F, F, G]
--   </pre>
base2 :: Expr
prop_r0_base2 :: Bool

-- | Third base
--   
--   <pre>
--   [F, G, F]
--   </pre>
base3 :: Expr
prop_r0_base3 :: Bool

-- | <a>base1</a>, <a>base2</a>, and <a>base3</a>
--   
--   The language seeded by: <tt>FG</tt>, <tt>FFG</tt>, <tt>FGF</tt> with
--   the rules: <tt>FG == FFG == FGF</tt> is equivalent to the regular
--   language generated by the expression: <tt>(F+)G(F?)</tt>.
--   
--   We can use this to provide an isomorphism with a more combinatorically
--   friendly type (Nat, Bool)
--   
--   <pre>
--   gen :: Nat -&gt; Bool -&gt; Lang
--   gen n False = replicate n <tt>F</tt> &lt;&gt; <a>FG</a>
--   gen n _    = replicate n <tt>F</tt> &lt;&gt; <a>FGF</a>
--   
--   unGen :: Lang -&gt; (Nat, Bool)
--   unGen xs = (length (takeWhile (== <tt>F</tt>) xs) - 1, last xs == <tt>F</tt>)
--   </pre>
--   
--   We can also redefine the language as: <tt> base term: FG replacement
--   rules: s<i>G$</i>GF/ --____ toggle ending F s<i>F$</i><i> --</i>
--   s<i>^FF</i>F<i> --____ can always prepend an F, can remove an F unless
--   it matches </i>^FG/ s<i>^</i>F<i> --</i> </tt>
--   
--   The lines are natural isomorphisms and the <a>.</a> is functor
--   composition
--   
--   <pre>
--             (f . g)
--               / 
--              /   
--             /     
--            /       
--           /         
--   f . (f . g) --- (f . g) . f
--   </pre>
--   
--   I really, really like this diagram. It completely explains the
--   structure of this language.
bases :: Set Expr
prop_rs_bases :: Bool
prop_ex_bases :: Bool

-- | All replacements of an expression.
--   
--   Uses <a>replacements</a> on <a>base1</a>, <a>base2</a>, <a>base3</a>.
allReplacements :: Expr -> Set Expr

-- | It would be <tt><tt>coerce</tt> <a>replacements</a></tt> if GHC could
--   derive it
replacementsE :: Expr -> Set Expr -> Expr -> Set (Seq Lang)

-- | Alias for <a>allReplacements</a>
--   
--   See below for example printing function implementation (not working):
--   
--   <pre>
--   s :: Set Expr -&gt; IO ()
--   s x = (mapM_ (y _) -&gt; putStrLn . fmap (z -&gt; if z then <tt>F</tt> else <tt>G</tt>) . (toList :: Expr -&gt; [Lang]) $ y) . reverse . sort . fromList . S.toList) x &gt;&gt; putStrLn []
--   </pre>
r0 :: Expr -> Set Expr

-- | Nest a function on a value some number of times
nest :: Int -> (a -> a) -> a -> a

-- | Iterate on a <a>Set</a> of expressions with <a>allReplacements</a>
rs :: Set Expr -> Set Expr

-- | <a>rs</a>, the given number of times
rsn :: Int -> Set Expr -> Set Expr

-- | Iterate as in <a>rs</a>, but keep already seen values
ex :: Set Expr -> Set Expr

-- | <a>ex</a>, the given number of times
exn :: Int -> Set Expr -> Set Expr
quickCheckFGLang :: IO Bool
instance Test.QuickCheck.Arbitrary.Arbitrary Data.FGLang.Expr
instance Data.Hashable.Class.Hashable Data.FGLang.Expr
instance GHC.Show.Show Data.FGLang.Expr
instance GHC.Classes.Ord Data.FGLang.Expr
instance GHC.Classes.Eq Data.FGLang.Expr
instance Data.String.IsString Data.FGLang.Expr
