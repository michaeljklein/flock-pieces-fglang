<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE InstanceSigs #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE OverloadedLists #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE RankNTypes #-}</span><span>
</span><a name="line-4"></a><span>
</span><a name="line-5"></a><span class="hs-comment">-- |</span><span>
</span><a name="line-6"></a><span class="hs-comment">--</span><span>
</span><a name="line-7"></a><span class="hs-comment">-- We want: `Functor` isomorphisms between these compositions of @F@ and @G@:</span><span>
</span><a name="line-8"></a><span class="hs-comment">--</span><span>
</span><a name="line-9"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-10"></a><span class="hs-comment">--  F(G(A))    -- we have a composition of functors</span><span>
</span><a name="line-11"></a><span class="hs-comment">--  F(F(G(A))) -- we partition the outer functor into pieces such that `unique partition (xs :: f (g a))` is true for our partition (if it exists, of course, that's where graph coloring comes in)</span><span>
</span><a name="line-12"></a><span class="hs-comment">--  F(G(F(A))) -- we push the partition into the inner functor, resulting in the connected (f (g a)) pieces being joined along their partitions.</span><span>
</span><a name="line-13"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-14"></a><span class="hs-comment">--</span><span>
</span><a name="line-15"></a><span class="hs-comment">-- In other words, it pulls the partition up to @F@'s level while pushing the structure of @F@ down into @G@.</span><span>
</span><a name="line-16"></a><span class="hs-comment">-- The structure of @F@ is available to @G@ in slices (local by definition of the partition).</span><span>
</span><a name="line-17"></a><span class="hs-comment">--</span><span>
</span><a name="line-18"></a><span class="hs-comment">-- Note: all of these operations are invertible since we have unique partitions (though I think I'm missing some constraints?)</span><span>
</span><a name="line-19"></a><span class="hs-comment">--</span><span>
</span><a name="line-20"></a><span class="hs-comment">-- Additionally, the functors which this works for are local functors and computers _really_ like computational and data locality.</span><span>
</span><a name="line-21"></a><span class="hs-comment">-- Computational locality makes stream and massively parallel processing a breeze (case in point, the line-by-line parser I just wrote).</span><span>
</span><a name="line-22"></a><span class="hs-comment">--</span><span>
</span><a name="line-23"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-24"></a><span class="hs-comment">--   f :: X -&gt; Y =&gt; F(G(f)) :: F(G(X)) -&gt; F(G(Y))</span><span>
</span><a name="line-25"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-26"></a><span class="hs-comment">--</span><span>
</span><a name="line-27"></a><span class="hs-comment">--</span><span>
</span><a name="line-28"></a><span class="hs-comment">-- That is, we want three natural transformations that are also isomorphisms between those compositions:</span><span>
</span><a name="line-29"></a><span class="hs-comment">--</span><span>
</span><a name="line-30"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-31"></a><span class="hs-comment">--   X :: C =&gt; eta_1(X) :: F(G(X)) -&gt; F(F(G(X))) :: C -&gt; C</span><span>
</span><a name="line-32"></a><span class="hs-comment">--   X :: C =&gt; eta_2(X) :: F(F(G(X))) -&gt; F(G(F(X))) :: C -&gt; C</span><span>
</span><a name="line-33"></a><span class="hs-comment">--   X :: C =&gt; eta_3(X) :: F(G(F(X))) -&gt; F(G(X)) :: C -&gt; C</span><span>
</span><a name="line-34"></a><span class="hs-comment">--</span><span>
</span><a name="line-35"></a><span class="hs-comment">--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_1(Y) . F(G(f)) = F(F(G(f))) . eta_1(X) :: F(G(X)) -&gt; F(F(G(Y))) :: C -&gt; C</span><span>
</span><a name="line-36"></a><span class="hs-comment">--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_2(Y) . F(F(G(f))) = F(G(F(f))) . eta_2(X) :: F(F(G(X))) -&gt; F(G(F(Y))) :: C -&gt; C</span><span>
</span><a name="line-37"></a><span class="hs-comment">--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_3(Y) . F(G(F(f))) = F(G(f)) . eta_3(X) :: F(G(F(X))) -&gt; F(G(Y)) :: C -&gt; C</span><span>
</span><a name="line-38"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-39"></a><span class="hs-comment">--</span><span>
</span><a name="line-40"></a><span class="hs-comment">-- We require these natural transformations to be bijections.</span><span>
</span><a name="line-41"></a><span class="hs-comment">--</span><span>
</span><a name="line-42"></a><span class="hs-comment">--</span><span>
</span><a name="line-43"></a><span class="hs-comment">-- Misc. notes:</span><span>
</span><a name="line-44"></a><span class="hs-comment">--</span><span>
</span><a name="line-45"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-46"></a><span class="hs-comment">-- h = f . h</span><span>
</span><a name="line-47"></a><span class="hs-comment">-- h -&gt; f . h</span><span>
</span><a name="line-48"></a><span class="hs-comment">-- h . g -&gt; h . g . f</span><span>
</span><a name="line-49"></a><span class="hs-comment">--</span><span>
</span><a name="line-50"></a><span class="hs-comment">-- f . h -&gt; h</span><span>
</span><a name="line-51"></a><span class="hs-comment">-- h . g . f -&gt; h . g</span><span>
</span><a name="line-52"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-53"></a><span class="hs-comment">--</span><span>
</span><a name="line-54"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-55"></a><span class="hs-comment">--  a pusher is guaranteed to push all it can over at once only if f is pointed and props hold.</span><span>
</span><a name="line-56"></a><span class="hs-comment">--</span><span>
</span><a name="line-57"></a><span class="hs-comment">--  (i think) a copusher .. iff f is copointed and props hold</span><span>
</span><a name="line-58"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-59"></a><span class="hs-comment">--</span><span>
</span><a name="line-60"></a><span class="hs-comment">-- This effectively reduces @(f+gf*)@ to @(fgf?)@. Is this reduction a pushing of compositions of @f@ inside?</span><span>
</span><a name="line-61"></a><span class="hs-comment">--</span><span>
</span><a name="line-62"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-63"></a><span class="hs-comment">--   yeah, what I've done is taken the set of words in the language, partitioned them on their compositions without all of the (return)'s, and given you a view inside that newly partitioned language.</span><span>
</span><a name="line-64"></a><span class="hs-comment">--   Really, really cool. I think this means that the partition interpretation mught be precise.</span><span>
</span><a name="line-65"></a><span class="hs-comment">--   ok, so let's say we have a partition (p), which is a natual transformation from (g a) to some index functor.</span><span>
</span><a name="line-66"></a><span class="hs-comment">--     ahh, since p is an endofunctor, we only really need to have `p` be an injection, and can make the index functor `f (g a)`</span><span>
</span><a name="line-67"></a><span class="hs-comment">--     really, we want the maximal (f (g a) -&gt; f (f (g a))) function such that pushing over pushes everything that can be over,</span><span>
</span><a name="line-68"></a><span class="hs-comment">--     we want to partition on (g a) such that we can reconstruct the structure of a connected component of g's in the partition inside of (g a)</span><span>
</span><a name="line-69"></a><span class="hs-comment">--  in other words, we need to ensure that the lines of the connected components do not cross the lines of what parts of `f` can be passed through `g`.</span><span>
</span><a name="line-70"></a><span class="hs-comment">--    first of all, in what sense does `f` form a graph, that we can accurrately describe what parts are adjacent?</span><span>
</span><a name="line-71"></a><span class="hs-comment">--      if `f` is pointed, then those components that cannot pass through are those such that: (push == fmap (fmap return) :: f . g -&gt; f . g . f)</span><span>
</span><a name="line-72"></a><span class="hs-comment">--      so we get a relation `can pass through(To) :: f g (a)`, where push is non-trivial</span><span>
</span><a name="line-73"></a><span class="hs-comment">--      we can also use (return) to specify that everything has passed through. we then can know: has anything passed through on `x` step, has everything passed through, really everything about what has passed through when</span><span>
</span><a name="line-74"></a><span class="hs-comment">--      p  :: g a -&gt; b</span><span>
</span><a name="line-75"></a><span class="hs-comment">--      p' :: f (g a) -&gt; b</span><span>
</span><a name="line-76"></a><span class="hs-comment">--      p' (return x) = p x</span><span>
</span><a name="line-77"></a><span class="hs-comment">--      extractor :: f b -&gt; maybe b</span><span>
</span><a name="line-78"></a><span class="hs-comment">--      p' = extractor . fmap p</span><span>
</span><a name="line-79"></a><span class="hs-comment">--      extractor (p &lt;$&gt; return x) = p x</span><span>
</span><a name="line-80"></a><span class="hs-comment">--      ahh, we can have a natural extractor, \y -&gt; { x | f associates x with y} :: f (g a) -&gt; {g a}</span><span>
</span><a name="line-81"></a><span class="hs-comment">--      so we require that. \y -&gt; forall (x :: g a). f x == y =&gt; p x :: f (g a) -&gt; Bool (the property maps all of the elements of the preimage to the same value)</span><span>
</span><a name="line-82"></a><span class="hs-comment">--       and that holds forall (f (g a)) `elem` (f (f (g a)))</span><span>
</span><a name="line-83"></a><span class="hs-comment">--       which also has a most general format of: \y -&gt; { x | f associates x with y &amp;&amp; x `elem` y}</span><span>
</span><a name="line-84"></a><span class="hs-comment">--       which I believe is both a valid inclusion and the most general inclusion</span><span>
</span><a name="line-85"></a><span class="hs-comment">--       valid inclusion: (x `elem` return x), x `elem` y =&gt; forall f. f x `elem` fmap f y</span><span>
</span><a name="line-86"></a><span class="hs-comment">--         if this is all we need then we get it from (x `elem` return x) and f being a functor [else hi]</span><span>
</span><a name="line-87"></a><span class="hs-comment">--           (all singleton (== return x) preimages for `f` implies f == const | identity?)</span><span>
</span><a name="line-88"></a><span class="hs-comment">--      and this predicate has: fmap pred . partition == fmap (const True) . partition</span><span>
</span><a name="line-89"></a><span class="hs-comment">--      and the partition is preserved by crossing `g`?</span><span>
</span><a name="line-90"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-91"></a><span class="hs-comment">--</span><span>
</span><a name="line-92"></a><span class="hs-comment">-- Alright, we want to classify each operation as being idempotent, and find what results we have.</span><span>
</span><a name="line-93"></a><span class="hs-comment">--</span><span>
</span><a name="line-94"></a><span class="hs-comment">-- We already have that all being idempotent implies that `f` is pointed and the second operation is equivalent to fmapping the pointing function up to the difference in types.</span><span>
</span><a name="line-95"></a><span class="hs-comment">--</span><span>
</span><a name="line-96"></a><span class="hs-comment">--</span><span>
</span><a name="line-97"></a><span class="hs-comment">-- Since the category probably doesn't have bool (if that even makes sense), if it's the unit category then the partition is trivial, else it holds for mapping any pair of elements of C to (False, True)</span><span>
</span><a name="line-98"></a><span class="hs-comment">--</span><span>
</span><a name="line-99"></a><span class="hs-comment">-- Really, it works either way, so we can just skip to it:</span><span>
</span><a name="line-100"></a><span class="hs-comment">--</span><span>
</span><a name="line-101"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-102"></a><span class="hs-comment">--  the checker does (if pred then xx else yy) and then we have:</span><span>
</span><a name="line-103"></a><span class="hs-comment">--  fmap checker . partition == fmap (const xx) . partition</span><span>
</span><a name="line-104"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-105"></a><span class="hs-comment">--</span><span>
</span><a name="line-106"></a><span class="hs-comment">-- Question: is the @checker@ function a valid function in the category? I'm not sure.</span><span>
</span><a name="line-107"></a><span class="hs-comment">-- We may have to fall back to a fold.</span><span>
</span><a name="line-108"></a><span class="hs-comment">--</span><span>
</span><a name="line-109"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Scratch</span><span class="hs-operator">.</span><span class="hs-identifier">FGLang</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-110"></a><span>
</span><a name="line-111"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">liftM2</span><span class="hs-special">)</span><span>
</span><a name="line-112"></a><span class="hs-keyword">import</span><span> </span><a href="Data.Hashable.Orphans.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Hashable</span><span class="hs-operator">.</span><span class="hs-identifier">Orphans</span></a><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span>
</span><a name="line-113"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Monoid</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">&lt;&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-114"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Sequence</span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">filter</span><span class="hs-special">)</span><span>
</span><a name="line-115"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Prelude</span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">filter</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">reverse</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">map</span><span class="hs-special">)</span><span>
</span><a name="line-116"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">HashSet</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">S</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">map</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">fromList</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">unions</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">toList</span><span class="hs-special">)</span><span>
</span><a name="line-117"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Prelude</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">P</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">filter</span><span class="hs-special">)</span><span>
</span><a name="line-118"></a><span class="hs-keyword">import</span><span> </span><a href="Data.HashSet.Utils.html"><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">HashSet</span><span class="hs-operator">.</span><span class="hs-identifier">Utils</span></a><span> </span><span class="hs-special">(</span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span class="hs-special">,</span><span> </span><a href="Data.HashSet.Utils.html#replacements"><span class="hs-identifier hs-var">replacements</span></a><span class="hs-special">)</span><span>
</span><a name="line-119"></a><span>
</span><a name="line-120"></a><span>
</span><a name="line-121"></a><span>
</span><a name="line-122"></a><span>
</span><a name="line-123"></a><span class="hs-comment">-- | Just `Bool`, tried making it its own data type</span><span>
</span><a name="line-124"></a><span class="hs-comment">--</span><span>
</span><a name="line-125"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-126"></a><span class="hs-comment">--   f . g     = f . f . g</span><span>
</span><a name="line-127"></a><span class="hs-comment">--   f . f . g = f . g . f</span><span>
</span><a name="line-128"></a><span class="hs-comment">--   f . g     = f . g . f</span><span>
</span><a name="line-129"></a><span class="hs-comment">--</span><span>
</span><a name="line-130"></a><span class="hs-comment">--   (f . g) . f = (f . g . f) . f</span><span>
</span><a name="line-131"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-132"></a><span class="hs-comment">--</span><span>
</span><a name="line-133"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-134"></a><span class="hs-comment">-- data Lang = F | G deriving (Eq, Ord, Show)</span><span>
</span><a name="line-135"></a><span class="hs-comment">--</span><span>
</span><a name="line-136"></a><span class="hs-comment">-- FG = FFG = FGF</span><span>
</span><a name="line-137"></a><span class="hs-comment">--</span><span>
</span><a name="line-138"></a><span class="hs-comment">-- instance Hashable Lang where</span><span>
</span><a name="line-139"></a><span class="hs-comment">--   hashWithSalt = hashUsing (== F)</span><span>
</span><a name="line-140"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-141"></a><span class="hs-comment">--</span><span>
</span><a name="line-142"></a><span class="hs-keyword">type</span><span> </span><a name="Lang"><a href="Scratch.FGLang.html#Lang"><span class="hs-identifier">Lang</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-type">Bool</span><span>
</span><a name="line-143"></a><span>
</span><a name="line-144"></a><span class="hs-comment">-- | An expression is a sqeuence of `Lang`s</span><span>
</span><a name="line-145"></a><span class="hs-keyword">type</span><span> </span><a name="Expr"><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier">Expr</span></a></a><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-type">Seq</span><span> </span><a href="Scratch.FGLang.html#Lang"><span class="hs-identifier hs-type">Lang</span></a><span>
</span><a name="line-146"></a><span>
</span><a name="line-147"></a><span class="hs-comment">-- | Parse an `Expr`.</span><span>
</span><a name="line-148"></a><span class="hs-comment">--</span><span>
</span><a name="line-149"></a><span class="hs-comment">-- For example:</span><span>
</span><a name="line-150"></a><span class="hs-comment">--</span><span>
</span><a name="line-151"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-152"></a><span class="hs-comment">--  &#955;&gt; parse &quot;GFGFGGFFGF&quot;</span><span>
</span><a name="line-153"></a><span class="hs-comment">--  fromList [True,False,True,False,True,True,False,False,True,False]</span><span>
</span><a name="line-154"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-155"></a><span class="hs-comment">--</span><span>
</span><a name="line-156"></a><span class="hs-identifier">parse</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-157"></a><a name="parse"><a href="Scratch.FGLang.html#parse"><span class="hs-identifier">parse</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">fromList</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">fmap</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><a name="local-6989586621679089077"><a href="#local-6989586621679089077"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">if</span><span> </span><a href="#local-6989586621679089077"><span class="hs-identifier hs-var">x</span></a><span> </span><span class="hs-operator hs-var">==</span><span> </span><span class="hs-char">'F'</span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-identifier hs-var">False</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-identifier hs-var">True</span><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">P</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">filter</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">liftM2</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">||</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">==</span><span> </span><span class="hs-char">'F'</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">==</span><span> </span><span class="hs-char">'G'</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-158"></a><span>
</span><a name="line-159"></a><span class="hs-comment">-- | Abbreviation for `parse`</span><span>
</span><a name="line-160"></a><span class="hs-identifier">p</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-161"></a><a name="p"><a href="Scratch.FGLang.html#p"><span class="hs-identifier">p</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Scratch.FGLang.html#parse"><span class="hs-identifier hs-var">parse</span></a><span>
</span><a name="line-162"></a><span>
</span><a name="line-163"></a><span>
</span><a name="line-164"></a><span>
</span><a name="line-165"></a><span>
</span><a name="line-166"></a><span class="hs-comment">-- | First base</span><span>
</span><a name="line-167"></a><span class="hs-comment">--</span><span>
</span><a name="line-168"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-169"></a><span class="hs-comment">-- [F, G]</span><span>
</span><a name="line-170"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-171"></a><span class="hs-comment">--</span><span>
</span><a name="line-172"></a><span class="hs-identifier">base1</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-173"></a><a name="base1"><a href="Scratch.FGLang.html#base1"><span class="hs-identifier">base1</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-var">True</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">False</span><span class="hs-special">]</span><span>
</span><a name="line-174"></a><span>
</span><a name="line-175"></a><span class="hs-comment">-- | Second base</span><span>
</span><a name="line-176"></a><span class="hs-comment">--</span><span>
</span><a name="line-177"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-178"></a><span class="hs-comment">-- [F, F, G]</span><span>
</span><a name="line-179"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-180"></a><span class="hs-comment">--</span><span>
</span><a name="line-181"></a><span class="hs-identifier">base2</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-182"></a><a name="base2"><a href="Scratch.FGLang.html#base2"><span class="hs-identifier">base2</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-var">True</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">False</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">False</span><span class="hs-special">]</span><span>
</span><a name="line-183"></a><span>
</span><a name="line-184"></a><span class="hs-comment">-- | Third base</span><span>
</span><a name="line-185"></a><span class="hs-comment">--</span><span>
</span><a name="line-186"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-187"></a><span class="hs-comment">-- [F, G, F]</span><span>
</span><a name="line-188"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-189"></a><span class="hs-comment">--</span><span>
</span><a name="line-190"></a><span class="hs-identifier">base3</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-191"></a><a name="base3"><a href="Scratch.FGLang.html#base3"><span class="hs-identifier">base3</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-identifier hs-var">True</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">False</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">True</span><span class="hs-special">]</span><span>
</span><a name="line-192"></a><span>
</span><a name="line-193"></a><span class="hs-comment">-- | `base1`, `base2`, and `base3`</span><span>
</span><a name="line-194"></a><span class="hs-comment">--</span><span>
</span><a name="line-195"></a><span class="hs-comment">-- The language seeded by: @FG@, @FFG@, @FGF@ with the rules: @FG == FFG == FGF@</span><span>
</span><a name="line-196"></a><span class="hs-comment">--   is equivalent to the regular language generated by the expression: @(F+)G(F?)@.</span><span>
</span><a name="line-197"></a><span class="hs-comment">--</span><span>
</span><a name="line-198"></a><span class="hs-comment">-- We can use this to provide an isomorphism with a more combinatorically friendly type (Nat, Bool)</span><span>
</span><a name="line-199"></a><span class="hs-comment">--</span><span>
</span><a name="line-200"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-201"></a><span class="hs-comment">--   gen :: Nat -&gt; Bool -&gt; Lang</span><span>
</span><a name="line-202"></a><span class="hs-comment">--   gen n False = replicate n 'F' &lt;&gt; &quot;FG&quot;</span><span>
</span><a name="line-203"></a><span class="hs-comment">--   gen n _    = replicate n 'F' &lt;&gt; &quot;FGF&quot;</span><span>
</span><a name="line-204"></a><span class="hs-comment">--</span><span>
</span><a name="line-205"></a><span class="hs-comment">--   unGen :: Lang -&gt; (Nat, Bool)</span><span>
</span><a name="line-206"></a><span class="hs-comment">--   unGen xs = (length (takeWhile (== 'F') xs) - 1, last xs == 'F')</span><span>
</span><a name="line-207"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-208"></a><span class="hs-comment">--</span><span>
</span><a name="line-209"></a><span class="hs-comment">-- We can also redefine the language as:</span><span>
</span><a name="line-210"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-211"></a><span class="hs-comment">--   base term:</span><span>
</span><a name="line-212"></a><span class="hs-comment">--     FG</span><span>
</span><a name="line-213"></a><span class="hs-comment">--   replacement rules:</span><span>
</span><a name="line-214"></a><span class="hs-comment">--     s/G$/GF/   --\____ toggle ending F</span><span>
</span><a name="line-215"></a><span class="hs-comment">--     s/F$//     --/</span><span>
</span><a name="line-216"></a><span class="hs-comment">--     s/^FF/F/   --\____ can always prepend an F, can remove an F unless it matches /^FG/</span><span>
</span><a name="line-217"></a><span class="hs-comment">--     s/^/F/     --/</span><span>
</span><a name="line-218"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-219"></a><span class="hs-comment">--</span><span>
</span><a name="line-220"></a><span class="hs-comment">--</span><span>
</span><a name="line-221"></a><span class="hs-comment">-- The lines are natural isomorphisms and the '.' is functor composition</span><span>
</span><a name="line-222"></a><span class="hs-comment">--</span><span>
</span><a name="line-223"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-224"></a><span class="hs-comment">--</span><span>
</span><a name="line-225"></a><span class="hs-comment">--             (f . g)</span><span>
</span><a name="line-226"></a><span class="hs-comment">--               / \
--              /   \
--             /     \
--            /       \
--           /         \
--   f . (f . g) --- (f . g) . f</span><span>
</span><a name="line-232"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-233"></a><span class="hs-comment">--</span><span>
</span><a name="line-234"></a><span class="hs-comment">-- I really, really like this diagram.</span><span>
</span><a name="line-235"></a><span class="hs-comment">-- It completely explains the structure of this language.</span><span>
</span><a name="line-236"></a><span class="hs-comment">--</span><span>
</span><a name="line-237"></a><span class="hs-identifier">bases</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-238"></a><a name="bases"><a href="Scratch.FGLang.html#bases"><span class="hs-identifier">bases</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">S</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">fromList</span><span> </span><span class="hs-special">[</span><a href="Scratch.FGLang.html#base1"><span class="hs-identifier hs-var">base1</span></a><span class="hs-special">,</span><span> </span><a href="Scratch.FGLang.html#base2"><span class="hs-identifier hs-var">base2</span></a><span class="hs-special">,</span><span> </span><a href="Scratch.FGLang.html#base3"><span class="hs-identifier hs-var">base3</span></a><span class="hs-special">]</span><span>
</span><a name="line-239"></a><span>
</span><a name="line-240"></a><span class="hs-comment">-- | All replacements of an expression.</span><span>
</span><a name="line-241"></a><span class="hs-comment">--</span><span>
</span><a name="line-242"></a><span class="hs-comment">-- Uses `replacements` on `base1`, `base2`, `base3`.</span><span>
</span><a name="line-243"></a><span class="hs-identifier">allReplacements</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-244"></a><a name="allReplacements"><a href="Scratch.FGLang.html#allReplacements"><span class="hs-identifier">allReplacements</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><a name="local-6989586621679089236"><a href="#local-6989586621679089236"><span class="hs-identifier">x</span></a></a><span> </span><a name="local-6989586621679089237"><a href="#local-6989586621679089237"><span class="hs-identifier">y</span></a></a><span> </span><a name="local-6989586621679089238"><a href="#local-6989586621679089238"><span class="hs-identifier">z</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679089236"><span class="hs-identifier hs-var">x</span></a><span> </span><span class="hs-operator hs-var">&lt;&gt;</span><span> </span><a href="#local-6989586621679089237"><span class="hs-identifier hs-var">y</span></a><span> </span><span class="hs-operator hs-var">&lt;&gt;</span><span> </span><a href="#local-6989586621679089238"><span class="hs-identifier hs-var">z</span></a><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="Data.HashSet.Utils.html#replacements"><span class="hs-identifier hs-var">replacements</span></a><span> </span><a href="Scratch.FGLang.html#base1"><span class="hs-identifier hs-var">base1</span></a><span> </span><span class="hs-special">[</span><a href="Scratch.FGLang.html#base2"><span class="hs-identifier hs-var">base2</span></a><span class="hs-special">,</span><span> </span><a href="Scratch.FGLang.html#base3"><span class="hs-identifier hs-var">base3</span></a><span class="hs-special">]</span><span> </span><span class="hs-operator hs-var">&lt;*&gt;</span><span> </span><a href="Data.HashSet.Utils.html#replacements"><span class="hs-identifier hs-var">replacements</span></a><span> </span><a href="Scratch.FGLang.html#base2"><span class="hs-identifier hs-var">base2</span></a><span> </span><span class="hs-special">[</span><a href="Scratch.FGLang.html#base1"><span class="hs-identifier hs-var">base1</span></a><span class="hs-special">,</span><span> </span><a href="Scratch.FGLang.html#base3"><span class="hs-identifier hs-var">base3</span></a><span class="hs-special">]</span><span> </span><span class="hs-operator hs-var">&lt;*&gt;</span><span> </span><a href="Data.HashSet.Utils.html#replacements"><span class="hs-identifier hs-var">replacements</span></a><span> </span><a href="Scratch.FGLang.html#base3"><span class="hs-identifier hs-var">base3</span></a><span> </span><span class="hs-special">[</span><a href="Scratch.FGLang.html#base1"><span class="hs-identifier hs-var">base1</span></a><span class="hs-special">,</span><span> </span><a href="Scratch.FGLang.html#base2"><span class="hs-identifier hs-var">base2</span></a><span class="hs-special">]</span><span>
</span><a name="line-245"></a><span>
</span><a name="line-246"></a><span>
</span><a name="line-247"></a><span>
</span><a name="line-248"></a><span class="hs-comment">-- | Alias for `allReplacements`</span><span>
</span><a name="line-249"></a><span class="hs-comment">--</span><span>
</span><a name="line-250"></a><span class="hs-comment">-- See below for example printing function implementation (not working):</span><span>
</span><a name="line-251"></a><span class="hs-comment">--</span><span>
</span><a name="line-252"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-253"></a><span class="hs-comment">-- s :: Set Expr -&gt; IO ()</span><span>
</span><a name="line-254"></a><span class="hs-comment">-- s x = (mapM_ (\y _) -&gt; putStrLn . fmap (\z -&gt; if z then 'F' else 'G') . (toList :: Expr -&gt; [Lang]) $ y) . reverse . sort . fromList . S.toList) x &gt;&gt; putStrLn []</span><span>
</span><a name="line-255"></a><span class="hs-comment">-- @</span><span>
</span><a name="line-256"></a><span class="hs-comment">--</span><span>
</span><a name="line-257"></a><span class="hs-identifier">r0</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-258"></a><a name="r0"><a href="Scratch.FGLang.html#r0"><span class="hs-identifier">r0</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Scratch.FGLang.html#allReplacements"><span class="hs-identifier hs-var">allReplacements</span></a><span>
</span><a name="line-259"></a><span>
</span><a name="line-260"></a><span>
</span><a name="line-261"></a><span class="hs-comment">-- | Nest a function on a value some number of times</span><span>
</span><a name="line-262"></a><span class="hs-identifier">nest</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Int</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><a href="#local-6989586621679089076"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679089076"><span class="hs-identifier hs-type">a</span></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679089076"><span class="hs-identifier hs-type">a</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679089076"><span class="hs-identifier hs-type">a</span></a><span>
</span><a name="line-263"></a><a name="nest"><a href="Scratch.FGLang.html#nest"><span class="hs-identifier">nest</span></a></a><span> </span><span class="hs-number">0</span><span> </span><span class="hs-identifier">_</span><span> </span><a name="local-6989586621679089239"><a href="#local-6989586621679089239"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="#local-6989586621679089239"><span class="hs-identifier hs-var">x</span></a><span>
</span><a name="line-264"></a><span class="hs-identifier">nest</span><span> </span><a name="local-6989586621679089240"><a href="#local-6989586621679089240"><span class="hs-identifier">n</span></a></a><span> </span><a name="local-6989586621679089241"><a href="#local-6989586621679089241"><span class="hs-identifier">f</span></a></a><span> </span><a name="local-6989586621679089242"><a href="#local-6989586621679089242"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Scratch.FGLang.html#nest"><span class="hs-identifier hs-var">nest</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679089240"><span class="hs-identifier hs-var">n</span></a><span> </span><span class="hs-glyph">-</span><span> </span><span class="hs-number">1</span><span class="hs-special">)</span><span> </span><a href="#local-6989586621679089241"><span class="hs-identifier hs-var">f</span></a><span> </span><span class="hs-special">(</span><a href="#local-6989586621679089241"><span class="hs-identifier hs-var">f</span></a><span> </span><a href="#local-6989586621679089242"><span class="hs-identifier hs-var">x</span></a><span class="hs-special">)</span><span>
</span><a name="line-265"></a><span>
</span><a name="line-266"></a><span>
</span><a name="line-267"></a><span class="hs-comment">-- | Iterate on a `Set` of expressions with `allReplacements`</span><span>
</span><a name="line-268"></a><span class="hs-identifier">rs</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-269"></a><a name="rs"><a href="Scratch.FGLang.html#rs"><span class="hs-identifier">rs</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">S</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">unions</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">S</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">toList</span><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">S</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">map</span><span> </span><a href="Scratch.FGLang.html#allReplacements"><span class="hs-identifier hs-var">allReplacements</span></a><span>
</span><a name="line-270"></a><span>
</span><a name="line-271"></a><span class="hs-comment">-- | `rs`, the given number of times</span><span>
</span><a name="line-272"></a><span class="hs-identifier">rsn</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Int</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-273"></a><a name="rsn"><a href="Scratch.FGLang.html#rsn"><span class="hs-identifier">rsn</span></a></a><span> </span><a name="local-6989586621679089243"><a href="#local-6989586621679089243"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Scratch.FGLang.html#nest"><span class="hs-identifier hs-var">nest</span></a><span> </span><a href="#local-6989586621679089243"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="Scratch.FGLang.html#rs"><span class="hs-identifier hs-var">rs</span></a><span>
</span><a name="line-274"></a><span>
</span><a name="line-275"></a><span>
</span><a name="line-276"></a><span class="hs-comment">-- | Iterate as in `rs`, but keep already seen values</span><span>
</span><a name="line-277"></a><span class="hs-identifier">ex</span><span> </span><span class="hs-glyph">::</span><span> </span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-278"></a><a name="ex"><a href="Scratch.FGLang.html#ex"><span class="hs-identifier">ex</span></a></a><span> </span><a name="local-6989586621679089244"><a href="#local-6989586621679089244"><span class="hs-identifier">x</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Scratch.FGLang.html#rs"><span class="hs-identifier hs-var">rs</span></a><span> </span><a href="#local-6989586621679089244"><span class="hs-identifier hs-var">x</span></a><span> </span><span class="hs-operator hs-var">&lt;&gt;</span><span> </span><a href="#local-6989586621679089244"><span class="hs-identifier hs-var">x</span></a><span>
</span><a name="line-279"></a><span>
</span><a name="line-280"></a><span class="hs-comment">-- | `ex`, the given number of times</span><span>
</span><a name="line-281"></a><span class="hs-identifier">exn</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Int</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="Data.HashSet.Utils.html#Set"><span class="hs-identifier hs-type">Set</span></a><span> </span><a href="Scratch.FGLang.html#Expr"><span class="hs-identifier hs-type">Expr</span></a><span>
</span><a name="line-282"></a><a name="exn"><a href="Scratch.FGLang.html#exn"><span class="hs-identifier">exn</span></a></a><span> </span><a name="local-6989586621679089245"><a href="#local-6989586621679089245"><span class="hs-identifier">n</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="Scratch.FGLang.html#nest"><span class="hs-identifier hs-var">nest</span></a><span> </span><a href="#local-6989586621679089245"><span class="hs-identifier hs-var">n</span></a><span> </span><a href="Scratch.FGLang.html#ex"><span class="hs-identifier hs-var">ex</span></a><span>
</span><a name="line-283"></a><span>
</span><a name="line-284"></a><span>
</span><a name="line-285"></a></pre></body></html>