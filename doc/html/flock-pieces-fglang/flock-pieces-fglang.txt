-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package flock-pieces-fglang
@version 0.1.0.0

module Data.Flip

-- | A four-part mutually recursive data type
--   
--   Notes:
--   
--   Number of cycles: w.l.o.g we require the first element to be the
--   minimum
--   
--   <pre>
--   1 minimum
--   * permutations of all else
--   (n-1)! ?
--   </pre>
--   
--   E.g. for two, there's exactly one cycle:
--   
--   <pre>
--   Value, Container =&gt;
--     Value * Container (..), Container (Value * ..)
--     Value + Container (..), Container (Value + ..)
--   </pre>
--   
--   Interesting example: unary / binary
--   
--   <pre>
--   (a -&gt; b)
--   (a -&gt; b -&gt; c)
--   
--   a -&gt; b
--   a -&gt; (b -&gt; c)
--   a -&gt; (a, b, b -&gt; c)
--   b -&gt; (b, c)
--   a -&gt; (b, (b -&gt; (c, next)))
--   </pre>
--   
--   Want:
--   
--   Applicative instances for <a>F1</a>, <a>F3</a>
--   
--   <a>Comonad</a> instances for <a>F2</a>, <a>F4</a>
newtype F1 a b c
F1 :: (a -> F2 a b c) -> F1 a b c
[getF1] :: F1 a b c -> a -> F2 a b c

-- | Continuation of <a>F1</a>
newtype F2 a b c
F2 :: (b, F3 a b c) -> F2 a b c
[getF2] :: F2 a b c -> (b, F3 a b c)

-- | Continuation of <a>F2</a>
newtype F3 a b c
F3 :: (b -> F4 a b c) -> F3 a b c
[getF3] :: F3 a b c -> b -> F4 a b c

-- | Continuation of <a>F3</a>
newtype F4 a b c
F4 :: (c, F1 a b c) -> F4 a b c
[getF4] :: F4 a b c -> (c, F1 a b c)

-- | <a>id</a>
morphF11 :: F1 a b c -> F1 a b c
functorMorphF11 :: TestBatch

-- | <a>F2</a> to <a>F4</a>, then <a>F4</a> to <a>F1</a>
morphF21 :: F2 a b c -> F1 a b c
functorMorphF21 :: TestBatch

-- | <a>id</a>
morphF22 :: F2 a b c -> F2 a b c
functorMorphF22 :: TestBatch

-- | Get and <a>snd</a>
morphF23 :: F2 a b c -> F3 a b c
functorMorphF23 :: TestBatch

-- | Get and apply the <tt>b</tt> in <a>F2</a> to the function in <a>F3</a>
morphF24 :: F2 a b c -> F4 a b c
functorMorphF24 :: TestBatch

-- | <a>id</a>
morphF33 :: F3 a b c -> F3 a b c
functorMorphF33 :: TestBatch

-- | Get and <a>snd</a>
morphF41 :: F4 a b c -> F1 a b c
functorMorphF41 :: TestBatch

-- | <a>id</a>
morphF44 :: F4 a b c -> F4 a b c
functorMorphF44 :: TestBatch
testF1Functor :: TestBatch
testF2Functor :: TestBatch
testF3Functor :: TestBatch
testF4Functor :: TestBatch

-- | Stub instance

-- | Stub instance

-- | Note that of <a>F1</a>, <a>F2</a>, <a>F3</a>, and <a>F4</a>, only
--   <a>F4</a> is always a <a>Comonad</a> (if <tt>a ~ b ~ c</tt>, for
--   example, I believe <a>F2</a> would be one as well):
--   
--   <a>F1</a> would need <a>F2</a> to be a <a>Comonad</a>, and a default
--   value for <tt>a</tt>
--   
--   <a>F2</a> would require <a>F3</a> to be a <a>Comonad</a>
--   
--   <a>F3</a> would require a default value for <tt>b</tt>, and for
--   <a>F4</a> to be a <a>Comonad</a> (which I believe it is)
--   
--   <pre>
--   extend extract = ext
--     ext (F4 ~(x, xs)) = F4 (x, F1 . fmap (F2 . fmap (F3 . fmap ext . getF3) . getF2) . getF1 $ xs)
--   
--     since F1, F2, F3, getF1, getF2, getF3, fmap do not affect the values, aside from <tt>fmap ext</tt>, I believe this may be proof of: ext == id
--   
--   extend extract      = id
--   extract . extend f  = f
--   extend f . extend g = extend (f . extend g)
--   </pre>

-- | Like <a>flip</a>
newtype Flip f a b
Flip :: f b a -> Flip f a b
[getFlip] :: Flip f a b -> f b a

-- | <a>coerce</a>
withFlip :: (Flip f1 a1 b1 -> Flip f a b) -> f1 b1 a1 -> f b a

-- | <a>Flip</a> for three arguments
newtype Flip2 f a b c
Flip2 :: f c b a -> Flip2 f a b c
[getFlip2] :: Flip2 f a b c -> f c b a

-- | Coerce
withFlip2 :: (Flip2 f1 a1 b1 c1 -> Flip2 f a b c) -> f1 c1 b1 a1 -> f c b a

-- | A newtype to ensure generated functions (<a>Arbitrary</a>) are
--   inverses of each other
newtype SomeIso a b
SomeIso :: (b -> a, a -> b) -> SomeIso a b
[getSomeIso] :: SomeIso a b -> (b -> a, a -> b)

-- | Ignore arguments

-- | Unsigned integer addition is an inverse to subtraction

-- | Test <a>IsoFunctor</a>
testIsoFunctor :: (IsoFunctor f, EqProp (f a), Show (f a), Arbitrary (SomeIso a a), Arbitrary (f a)) => f a -> TestBatch

-- | A "functor" that requires an isomorphism to map over
class IsoFunctor f
isomap :: IsoFunctor f => (b -> a) -> (a -> b) -> f a -> f b

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF1 :: TestBatch

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF2 :: TestBatch

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF3 :: TestBatch

-- | Uses <a>Word</a>, <a>testIsoFunctor</a>
testIsoFunctorF4 :: TestBatch

-- | All <a>TestBatch</a>s
testBatches :: [TestBatch]

-- | Run all test batches using <a>quickBatch</a>
quickTestBatches :: IO ()
instance GHC.Show.Show (f c b a) => GHC.Show.Show (Data.Flip.Flip2 f a b c)
instance GHC.Classes.Ord (f c b a) => GHC.Classes.Ord (Data.Flip.Flip2 f a b c)
instance GHC.Classes.Eq (f c b a) => GHC.Classes.Eq (Data.Flip.Flip2 f a b c)
instance Test.QuickCheck.Arbitrary.Arbitrary (f b a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.Flip f a b)
instance Test.QuickCheck.Checkers.EqProp (f b a) => Test.QuickCheck.Checkers.EqProp (Data.Flip.Flip f a b)
instance GHC.Show.Show (f b a) => GHC.Show.Show (Data.Flip.Flip f a b)
instance GHC.Classes.Ord (f b a) => GHC.Classes.Ord (Data.Flip.Flip f a b)
instance GHC.Classes.Eq (f b a) => GHC.Classes.Eq (Data.Flip.Flip f a b)
instance GHC.Show.Show b => GHC.Show.Show (Data.Flip.F2 a b c)
instance GHC.Show.Show c => GHC.Show.Show (Data.Flip.F4 a b c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F1 a) c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F2 a) c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F3 a) c)
instance Data.Flip.IsoFunctor (Data.Flip.Flip (Data.Flip.F4 a) c)
instance GHC.Show.Show (Data.Flip.SomeIso a b)
instance Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.SomeIso GHC.Types.Word GHC.Types.Word)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F1 a b)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F2 a b)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F3 a b)
instance Data.Functor.Contravariant.Contravariant (Data.Flip.Flip2 Data.Flip.F4 a b)
instance GHC.Base.Functor (Data.Flip.F1 a b)
instance GHC.Base.Functor (Data.Flip.F2 a b)
instance GHC.Base.Functor (Data.Flip.F3 a b)
instance GHC.Base.Functor (Data.Flip.F4 a b)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F1 a b c)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F2 a b c)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F3 a b c)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Show.Show a, Test.QuickCheck.Arbitrary.Arbitrary b, GHC.Classes.Eq b, GHC.Show.Show b, GHC.Classes.Eq c) => Test.QuickCheck.Checkers.EqProp (Data.Flip.F4 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F1 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F2 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F3 a b c)
instance (Test.QuickCheck.Arbitrary.CoArbitrary a, Test.QuickCheck.Arbitrary.CoArbitrary b, Test.QuickCheck.Arbitrary.Arbitrary b, Test.QuickCheck.Arbitrary.Arbitrary c) => Test.QuickCheck.Arbitrary.Arbitrary (Data.Flip.F4 a b c)
instance GHC.Show.Show (Data.Flip.F1 a b c)
instance GHC.Show.Show (Data.Flip.F3 a b c)
instance Control.Comonad.Comonad (Data.Flip.F4 a b)

module Data.Functor.Join

-- | An isomorphism, as in:
--   <a>https://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Iso.html</a>
type Iso s t a b = forall p f. (Profunctor p, Functor f) => p a (f b) -> p s (f t)

-- | An isomorphism, specialized to two types
type Iso' s a = Iso s s a a

-- | Join two functors together
class (Functor f, Functor g) => Join f g
partition :: Join f g => Iso' (f (g a)) (f (f (g a)))
pushover :: Join f g => Iso' (f (f (g a))) (f (g (f a)))
push :: Join f g => Iso' (f (g a)) (f (g (f a)))

-- | Join left

-- | Join right

-- | Three types of join: left, right, and done
data JoinTypes
JoinL :: JoinTypes
JoinR :: JoinTypes
Joined :: JoinTypes

-- | <a>undefined</a>
joinL :: f (f a) -> f a

-- | <a>undefined</a>
joinR :: Join f g => f (g (f a)) -> f (g a)

-- | Simple wrapper
newtype F f a
F :: f a -> F f a
[getF] :: F f a -> f a

-- | Simple wrapper
newtype G g a
G :: g a -> G g a
[getG] :: G g a -> g a

-- | The type of a join

-- | If <tt>f (g a))</tt> then return, else recurse

-- | If zero, return, else recurse

-- | Next iteration of <a>Joining</a>
class Joining' (JoinType a) (JoinType b) => Joining a b
joining :: Joining a b => a -> b

-- | Generic function typeclass, helper for <a>Joining</a>
class Joining' a b
joining' :: Joining' a b => a -> b

-- | Notes:
--   
--   <pre>
--   instance Joining' (F f (G g (F f a)))
--   
--   class JoinedC n m f g a b
--   
--   data Joined n m f g a = forall b. JoinedC n m f g a b. Joined b
--   
--   SomeJoined f g a { Joined n m f g a }
--   
--   Joined n m f g a -&gt; Joined n' m' f g a
--   </pre>

-- | Next iteration of <a>JoinType</a>

-- | For this attempt, the instances are still pretty far from compiling:
--   
--   <pre>
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinL JoinL where
--     joining'' x = joinL . joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinL JoinR where
--     joining'' x = joinL . joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinL Joined where
--     joining'' x = joinL . joining'' x
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinR JoinL where
--     joining'' x = joinR . joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinR JoinR where
--     joining'' x = joinR . joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b JoinR Joined where
--     joining'' x = joinR . joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b Joined JoinL where
--     joining'' x =         joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b Joined JoinR where
--     joining'' x =         joining'' x . joinR
--   
--   instance Joining'' a b Joined Joined =&gt; Joining'' a b Joined Joined where
--     joining'' x = id
--   </pre>
class (JointL a ~ JointL b, JointR a ~ JointR b, Join (JointL a) (JointR b), JoinType''' a ~ joinTypeA, JoinType''' b ~ joinTypeB) => Joining'' a b (joinTypeA :: JoinTypes) (joinTypeB :: JoinTypes)
joining'' :: Joining'' a b joinTypeA joinTypeB => a -> b
instance GHC.Show.Show Data.Functor.Join.JoinTypes
instance GHC.Classes.Ord Data.Functor.Join.JoinTypes
instance GHC.Classes.Eq Data.Functor.Join.JoinTypes
instance (GHC.Base.Functor f, Data.Functor.Join.Joining' (Data.Functor.Join.F f a) (Data.Functor.Join.F f b)) => Data.Functor.Join.Joining' (Data.Functor.Join.F f (Data.Functor.Join.F f a)) (Data.Functor.Join.F f (Data.Functor.Join.F f b))
instance GHC.Base.Functor g => GHC.Base.Functor (Data.Functor.Join.G g)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Join.F f)

module Data.Functor.Object

-- | Both a right result and a continuation (<a>Action</a>)
data Object f b c
Object :: (c, Action f b c) -> Object f b c
[getObject] :: Object f b c -> (c, Action f b c)

-- | An action which could contain a left result, continuation
--   (<a>Object</a>)
data Action f b c
Action :: (f b (Object f b c)) -> Action f b c
[runAction] :: Action f b c -> (f b (Object f b c))

-- | Simple fixed point newtype
newtype Fix f
Fix :: f (Fix f) -> Fix f
[runFix] :: Fix f -> f (Fix f)

-- | Cycle a pair, resulting in a fixed point
cyclePair :: Object (,) a b -> Fix ((,) (a, b))

-- | Convert a <a>Fix</a> to an infinite list
fixList :: Fix ((,) a) -> [a]

-- | <a>Object</a>, but with a sum (<a>Either</a>) instead of a tuple
data Result f b c
Result :: Either c (Effect f b c) -> Result f b c
[getResult] :: Result f b c -> Either c (Effect f b c)

-- | <a>Action</a>, but with a sum (<a>Either</a>) instead of a tuple
data Effect f b c
Effect :: f b (Result f b c) -> Effect f b c
[runEffect] :: Effect f b c -> f b (Result f b c)

-- | Given all the functional pairs to define a function, we can cyclically
--   wrap the pairs into an <a>Action</a> over pairs.
--   
--   Consider generalizing to other nice <tt>(* -&gt; * -&gt; *)</tt>'s
fromAll :: NonEmpty (a, b) -> Action (,) a b

-- | interesting..
ish :: (a -> b -> (a', b')) -> NonEmpty a -> NonEmpty b -> Action (,) a' b'

-- | Effectively define <a>fst</a> for an <a>Action</a> over pairs, using
--   all cases
fstIsh :: NonEmpty a -> NonEmpty b -> Action (,) (a, b) a

-- | Effectively define <a>snd</a> for an <a>Action</a> over pairs, using
--   all cases
sndIsh :: NonEmpty a -> NonEmpty b -> Action (,) (a, b) b

-- | Since there's only a finite number of a's, we can cycle through til we
--   match, then continue on
appIsh :: (Eq a, Functor (f t)) => Action (,) a b -> Object f t a -> Object f t b

-- | Convert a flipped result to an either (sum)
toEither :: Flip (Result (Flip (Object f))) c b -> Either c b

-- | Convert a flipped result to a tuple (product)
toPair :: Flip (Object (Flip (Object f))) c b -> (c, b)

-- | Undo an <a>Action</a>
unAction :: Functor (f b) => Action f b c -> f b c

-- | Undo an <a>Object</a>
unObject :: Functor (f b) => Object f b c -> (f b c, c)

-- | Convert to an <a>Action</a>
toAction :: Functor (f b) => f b c -> Action f b c

-- | Convert to an <a>Object</a>
toObject :: Functor (f b) => f b c -> c -> Object f b c

-- | <a>toAction</a>
fstAction :: Functor (f (b, c)) => f (b, c) b -> Action f (b, c) b

-- | <a>toObject</a>
fstObject :: Functor (f (b, c)) => f (b, c) b -> b -> Object f (b, c) b

-- | <a>toAction</a>
sndAction :: Functor (f (b, c)) => f (b, c) c -> Action f (b, c) c

-- | <a>toObject</a>
sndObject :: Functor (f (b, c)) => f (b, c) c -> c -> Object f (b, c) c

-- | <a>toAction</a>
swapAction :: Functor (f (b, c)) => f (b, c) (c, b) -> Action f (b, c) (c, b)

-- | <a>toObject</a>
swapObject :: Functor (f (b, c)) => f (b, c) (c, b) -> (c, b) -> Object f (b, c) (c, b)

-- | <a>toAction</a>
mapEitherAction :: Functor (f (c -> d, Either b c)) => f (c -> d, Either b c) (Either b d) -> Action f (c -> d, Either b c) (Either b d)

-- | <a>toObject</a>
mapEitherObject :: Functor (f (c -> d, Either b c)) => f (c -> d, Either b c) (Either b d) -> Either b d -> Object f (c -> d, Either b c) (Either b d)
instance GHC.Generics.Generic (Data.Functor.Object.Fix f)
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Object.Result f b)
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Object.Effect f b)
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.Object.Fix ((,) a))
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Object.Object f b)
instance GHC.Base.Functor (f b) => GHC.Base.Functor (Data.Functor.Object.Action f b)
instance Control.Comonad.Comonad (f b) => Control.Comonad.Comonad (Data.Functor.Object.Object f b)
instance Control.Comonad.Comonad (f b) => Control.Comonad.Comonad (Data.Functor.Object.Action f b)

module Data.Functor.Turn

-- | A <a>Functor</a> <a>Turn</a>ing class..
--   
--   Ideas for implementing this language as a Haskell class:
--   
--   <pre>
--   givenExpression :: f (g a)
--   rturn ::        any (g a) <a>-</a> any (g (f a))
--   rturn :: C h =&gt; h   (g a) <a>-</a> h   (g (f a))
--   
--   lturn ::        any a <a>-</a> f (any a)
--   lturn :: C h =&gt; h   a  -&gt; f (h   a)
--   </pre>
--   
--   <pre>
--   class C f g where
--     base0 :: Turn f g (Compose f g) =&gt; ()
--     base1 :: Turn f g (Compose f (Compose g f)) =&gt; ()
--   
--     lturnWitness :: (Turn f g h =&gt; ()) -&gt; (Turn f g (Compose f h) =&gt; ())
--   
--   instance C (Base f g)
--   instance C (Compose h g) =&gt; C (Compose h (Compose g f))
--   instance C h =&gt; C (Compose f h)
--   </pre>
class Turn f g h | h -> f, h -> g

-- | Turn left
lturn :: Turn f g h => h a -> f (h a)

-- | Turn right
rturn :: Turn f g h => h (g a) -> h (g (f a))

-- | categorical dual of Turn
class Coturn f g h | h -> f, h -> g

-- | Co-Turn left
clturn :: Coturn f g h => f (h a) -> h a

-- | Co-Turn right
crturn :: Coturn f g h => h (g (f a)) -> h (g a)

-- | The free implementation of a "freely turning" data type
data FreeTurn f g a
[FreeLTurn] :: f (FreeTurn f g a) -> FreeTurn f g a
[FreeRTurn] :: FreeTurn f g (g a) -> FreeTurn f g (g (f a))

-- | Can we prove that <tt>(lturn (FreeRTurn x))</tt> is a type error?
--   
--   <pre>
--   FreeRTurn x :: FreeTurn f g (g (f a))
--   lturn       :: FreeTurn f g       a   -&gt; f (FreeTurn f g a)
--   
--   Thus g (f a) ~ a, a type error in standard haskell
--   </pre>
--   
--   Q.E.D.

-- | Free <a>Coturn</a>
data FreeCoturn f g a
[FreeLcoturn] :: f (FreeCoturn f g a) -> FreeCoturn f g a
[FreeRcoturn] :: FreeCoturn f g (g (f a)) -> FreeCoturn f g (g a)

-- | This one is easy

-- | Left and right turning data structure
data Turning f g a
[LTurn] :: f (Turning f g a) -> Turning f g a
[RTurn] :: Turning f g (g a) -> Turning f g (g (f a))
[RCoturn] :: Turning f g (g (f a)) -> Turning f g (g a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Turn.Turning f g)
instance Data.Functor.Turn.Turn f g (Data.Functor.Turn.Turning f g)
instance Data.Functor.Turn.Coturn f g (Data.Functor.Turn.Turning f g)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Turn.FreeCoturn f g)
instance Data.Functor.Turn.Coturn f g (Data.Functor.Turn.FreeCoturn f g)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Functor.Turn.FreeTurn f g)
instance Data.Functor.Turn.Turn f g (Data.Functor.Turn.FreeTurn f g)

module Data.Hashable.Orphans

-- | A left, strict fold using <a>hashWithSalt</a>

-- | Generate a random list, append a random value, and ensure their hashes
--   are different
testHashableSeq :: (Eq a, Hashable a) => a -> [a] -> Bool

-- | <tt>quickCheck</tt> <a>testHashableSeq</a>
prop_testHashableSeq :: Int -> [Int] -> Bool
quickCheckHashableSeq :: IO Bool
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Sequence.Internal.Seq a)

module Data.Tuple.Utils

-- | Apply a function to the first of a triple
first3 :: (a -> b) -> (a, c, d) -> (b, c, d)

-- | Get the first element of a triple
fst3 :: (a, b, c) -> a

-- | Get the second element of a triple
snd3 :: (a, b, c) -> b

-- | Get the third element of a triple
trd3 :: (a, b, c) -> c

module Data.HashSet.Utils

-- | Convenience synonym
type Set = HashSet

-- | All splits of a sequence <tt>(initial, current, rest)</tt>
allSplits :: (Eq a, Hashable a) => Seq a -> Set (Seq a, a, Seq a)
prop_allSplitsLength :: [Int] -> Bool

-- | Each should be equal to the original, when put back together
prop_allSplitsAreSplits :: [Int] -> Bool
prop_allSplitsHaveExpectedLengths :: [Int] -> Bool

-- | All splits of a sequence <tt>(initial, rest)</tt>
allSplits_ :: (Eq a, Hashable a) => Seq a -> Set (Seq a, Seq a)

-- | <pre>
--   length seq == length set
--   </pre>
prop_allSplits_Length :: [Int] -> Bool

-- | Each should be equal to the original, when put back together
prop_allSplits_AreSplits :: [Int] -> Bool
prop_allSplits_HaveExpectedLengths :: [Int] -> Bool

-- | Convert to list and then flatten using the union of two sets
flattenSet :: (Eq a, Hashable a) => Set (Set a) -> Set a

-- | All splits of a sequence on another sequence
splitsOn :: (Eq a, Hashable a) => Seq a -> Seq a -> Set (Seq a, Seq a)

-- | All one-application replacements
replacements :: (Eq a, Hashable a) => Seq a -> Set (Seq a) -> Seq a -> Set (Seq a)
quickCheckHashSetUtils :: IO Bool


-- | We want: <a>Functor</a> isomorphisms between these compositions of
--   <tt>F</tt> and <tt>G</tt>:
--   
--   <pre>
--   F(G(A))    -- we have a composition of functors
--   F(F(G(A))) -- we partition the outer functor into pieces such that `unique partition (xs :: f (g a))` is true for our partition (if it exists, of course, that's where graph coloring comes in)
--   F(G(F(A))) -- we push the partition into the inner functor, resulting in the connected (f (g a)) pieces being joined along their partitions.
--   </pre>
--   
--   In other words, it pulls the partition up to <tt>F</tt>'s level while
--   pushing the structure of <tt>F</tt> down into <tt>G</tt>. The
--   structure of <tt>F</tt> is available to <tt>G</tt> in slices (local by
--   definition of the partition).
--   
--   Note: all of these operations are invertible since we have unique
--   partitions (though I think I'm missing some constraints?)
--   
--   Additionally, the functors which this works for are local functors and
--   computers _really_ like computational and data locality. Computational
--   locality makes stream and massively parallel processing a breeze (case
--   in point, the line-by-line parser I just wrote).
--   
--   <pre>
--   f :: X -&gt; Y =&gt; F(G(f)) :: F(G(X)) -&gt; F(G(Y))
--   </pre>
--   
--   That is, we want three natural transformations that are also
--   isomorphisms between those compositions:
--   
--   <pre>
--   X :: C =&gt; eta_1(X) :: F(G(X)) -&gt; F(F(G(X))) :: C -&gt; C
--   X :: C =&gt; eta_2(X) :: F(F(G(X))) -&gt; F(G(F(X))) :: C -&gt; C
--   X :: C =&gt; eta_3(X) :: F(G(F(X))) -&gt; F(G(X)) :: C -&gt; C
--   
--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_1(Y) . F(G(f)) = F(F(G(f))) . eta_1(X) :: F(G(X)) -&gt; F(F(G(Y))) :: C -&gt; C
--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_2(Y) . F(F(G(f))) = F(G(F(f))) . eta_2(X) :: F(F(G(X))) -&gt; F(G(F(Y))) :: C -&gt; C
--   f :: X -&gt; Y :: C -&gt; C =&gt; eta_3(Y) . F(G(F(f))) = F(G(f)) . eta_3(X) :: F(G(F(X))) -&gt; F(G(Y)) :: C -&gt; C
--   </pre>
--   
--   We require these natural transformations to be bijections.
--   
--   Misc. notes:
--   
--   <pre>
--   h = f . h
--   h -&gt; f . h
--   h . g -&gt; h . g . f
--   
--   f . h -&gt; h
--   h . g . f -&gt; h . g
--   </pre>
--   
--   <pre>
--   a pusher is guaranteed to push all it can over at once only if f is pointed and props hold.
--   
--   (i think) a copusher .. iff f is copointed and props hold
--   </pre>
--   
--   This effectively reduces <tt>(f+gf*)</tt> to <tt>(fgf?)</tt>. Is this
--   reduction a pushing of compositions of <tt>f</tt> inside?
--   
--   <pre>
--    yeah, what I've done is taken the set of words in the language, partitioned them on their compositions without all of the (return)'s, and given you a view inside that newly partitioned language.
--    Really, really cool. I think this means that the partition interpretation mught be precise.
--    ok, so let's say we have a partition (p), which is a natual transformation from (g a) to some index functor.
--      ahh, since p is an endofunctor, we only really need to have <tt>p</tt> be an injection, and can make the index functor `f (g a)`
--      really, we want the maximal (f (g a) -&gt; f (f (g a))) function such that pushing over pushes everything that can be over,
--      we want to partition on (g a) such that we can reconstruct the structure of a connected component of g's in the partition inside of (g a)
--   in other words, we need to ensure that the lines of the connected components do not cross the lines of what parts of <tt>f</tt> can be passed through <tt>g</tt>.
--     first of all, in what sense does <tt>f</tt> form a graph, that we can accurrately describe what parts are adjacent?
--       if <tt>f</tt> is pointed, then those components that cannot pass through are those such that: (push == fmap (fmap return) :: f . g -&gt; f . g . f)
--       so we get a relation `can pass through(To) :: f g (a)`, where push is non-trivial
--       we can also use (return) to specify that everything has passed through. we then can know: has anything passed through on <tt>x</tt> step, has everything passed through, really everything about what has passed through when
--       p  :: g a -&gt; b
--       p' :: f (g a) -&gt; b
--       p' (return x) = p x
--       extractor :: f b -&gt; maybe b
--       p' = extractor . fmap p
--       extractor (p <a>$</a> return x) = p x
--       ahh, we can have a natural extractor, y -&gt; { x | f associates x with y} :: f (g a) -&gt; {g a}
--       so we require that. y -&gt; forall (x :: g a). f x == y =&gt; p x :: f (g a) -&gt; Bool (the property maps all of the elements of the preimage to the same value)
--        and that holds forall (f (g a)) <a>elem</a> (f (f (g a)))
--        which also has a most general format of: y -&gt; { x | f associates x with y &amp;&amp; x <a>elem</a> y}
--        which I believe is both a valid inclusion and the most general inclusion
--        valid inclusion: (x <a>elem</a> return x), x <a>elem</a> y =&gt; forall f. f x <a>elem</a> fmap f y
--          if this is all we need then we get it from (x <a>elem</a> return x) and f being a functor [else hi]
--            (all singleton (== return x) preimages for <tt>f</tt> implies f == const | identity?)
--       and this predicate has: fmap pred . partition == fmap (const True) . partition
--       and the partition is preserved by crossing <tt>g</tt>?
--   </pre>
--   
--   Alright, we want to classify each operation as being idempotent, and
--   find what results we have.
--   
--   We already have that all being idempotent implies that <tt>f</tt> is
--   pointed and the second operation is equivalent to fmapping the
--   pointing function up to the difference in types.
--   
--   Since the category probably doesn't have bool (if that even makes
--   sense), if it's the unit category then the partition is trivial, else
--   it holds for mapping any pair of elements of C to (False, True)
--   
--   Really, it works either way, so we can just skip to it:
--   
--   <pre>
--   the checker does (if pred then xx else yy) and then we have:
--   fmap checker . partition == fmap (const xx) . partition
--   </pre>
--   
--   Question: is the <tt>checker</tt> function a valid function in the
--   category? I'm not sure. We may have to fall back to a fold.
module Data.FGLang

-- | Just <a>Bool</a>, tried making it its own data type
--   
--   <pre>
--   f . g     = f . f . g
--   f . f . g = f . g . f
--   f . g     = f . g . f
--   
--   (f . g) . f = (f . g . f) . f
--   </pre>
--   
--   <pre>
--   data Lang = F | G deriving (Eq, Ord, Show)
--   
--   FG = FFG = FGF
--   
--   instance Hashable Lang where
--     hashWithSalt = hashUsing (== F)
--   </pre>
type Lang = Bool

-- | An expression is a sqeuence of <a>Lang</a>s
newtype Expr
Expr :: Seq Lang -> Expr
[getExpr] :: Expr -> Seq Lang

-- | A left, strict fold using <a>hashWithSalt</a> instance Hashable Expr
--   where hashWithSalt salt = foldl' hashWithSalt salt . getExpr
--   
--   Generate a random list, append a random value, and ensure their hashes
--   are different
prop_HashableExpr :: Bool -> [Bool] -> Bool

-- | Parse an <a>Expr</a>.
--   
--   For example:
--   
--   <pre>
--   λ&gt; parse <a>GFGFGGFFGF</a>
--   fromList [True,False,True,False,True,True,False,False,True,False]
--   </pre>
parse :: String -> Expr

-- | Test whether all of the elements of a list are equal.
--   
--   Taken from: <tt>pieces<i>inhabited</i>src<i>Data</i>Expr.hs</tt>
allEq :: Eq a => [a] -> Bool

-- | Test that parsing a string of only F, G is equal to parsing that
--   string with a not-F,G string prepended, appended, resp.
prop_parseIgnoresAllButFG :: [Bool] -> String -> Bool

-- | Static test case: <tt>parse <a>FGHBVDERTYHBGVCDSER</a> == parse
--   <a>FGG</a></tt>
prop_parseIgnoresAllButFG' :: Bool

-- | First base
--   
--   <pre>
--   [F, G]
--   </pre>
base1 :: Expr
prop_r0_base1 :: Bool

-- | Second base
--   
--   <pre>
--   [F, F, G]
--   </pre>
base2 :: Expr
prop_r0_base2 :: Bool

-- | Third base
--   
--   <pre>
--   [F, G, F]
--   </pre>
base3 :: Expr
prop_r0_base3 :: Bool

-- | <a>base1</a>, <a>base2</a>, and <a>base3</a>
--   
--   The language seeded by: <tt>FG</tt>, <tt>FFG</tt>, <tt>FGF</tt> with
--   the rules: <tt>FG == FFG == FGF</tt> is equivalent to the regular
--   language generated by the expression: <tt>(F+)G(F?)</tt>.
--   
--   We can use this to provide an isomorphism with a more combinatorically
--   friendly type (Nat, Bool)
--   
--   <pre>
--   gen :: Nat -&gt; Bool -&gt; Lang
--   gen n False = replicate n <tt>F</tt> &lt;&gt; <a>FG</a>
--   gen n _    = replicate n <tt>F</tt> &lt;&gt; <a>FGF</a>
--   
--   unGen :: Lang -&gt; (Nat, Bool)
--   unGen xs = (length (takeWhile (== <tt>F</tt>) xs) - 1, last xs == <tt>F</tt>)
--   </pre>
--   
--   We can also redefine the language as: <tt> base term: FG replacement
--   rules: s<i>G$</i>GF/ --____ toggle ending F s<i>F$</i><i> --</i>
--   s<i>^FF</i>F<i> --____ can always prepend an F, can remove an F unless
--   it matches </i>^FG/ s<i>^</i>F<i> --</i> </tt>
--   
--   The lines are natural isomorphisms and the <a>.</a> is functor
--   composition
--   
--   <pre>
--             (f . g)
--               / 
--              /   
--             /     
--            /       
--           /         
--   f . (f . g) --- (f . g) . f
--   </pre>
--   
--   I really, really like this diagram. It completely explains the
--   structure of this language.
bases :: Set Expr
prop_rs_bases :: Bool
prop_ex_bases :: Bool

-- | All replacements of an expression.
--   
--   Uses <a>replacements</a> on <a>base1</a>, <a>base2</a>, <a>base3</a>.
allReplacements :: Expr -> Set Expr

-- | It would be <tt><tt>coerce</tt> <a>replacements</a></tt> if GHC could
--   derive it
replacementsE :: Expr -> Set Expr -> Expr -> Set (Seq Lang)

-- | Alias for <a>allReplacements</a>
--   
--   See below for example printing function implementation (not working):
--   
--   <pre>
--   s :: Set Expr -&gt; IO ()
--   s x = (mapM_ (y _) -&gt; putStrLn . fmap (z -&gt; if z then <tt>F</tt> else <tt>G</tt>) . (toList :: Expr -&gt; [Lang]) $ y) . reverse . sort . fromList . S.toList) x &gt;&gt; putStrLn []
--   </pre>
r0 :: Expr -> Set Expr

-- | Nest a function on a value some number of times
nest :: Int -> (a -> a) -> a -> a

-- | Iterate on a <a>Set</a> of expressions with <a>allReplacements</a>
rs :: Set Expr -> Set Expr

-- | <a>rs</a>, the given number of times
rsn :: Int -> Set Expr -> Set Expr

-- | Iterate as in <a>rs</a>, but keep already seen values
ex :: Set Expr -> Set Expr

-- | <a>ex</a>, the given number of times
exn :: Int -> Set Expr -> Set Expr
quickCheckFGLang :: IO Bool
instance Test.QuickCheck.Arbitrary.Arbitrary Data.FGLang.Expr
instance Data.Hashable.Class.Hashable Data.FGLang.Expr
instance GHC.Show.Show Data.FGLang.Expr
instance GHC.Classes.Ord Data.FGLang.Expr
instance GHC.Classes.Eq Data.FGLang.Expr
instance Data.String.IsString Data.FGLang.Expr
