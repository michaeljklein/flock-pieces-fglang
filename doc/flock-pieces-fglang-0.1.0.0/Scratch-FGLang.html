<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Scratch.FGLang</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Scratch.FGLang.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">flock-pieces-fglang-0.1.0.0</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Scratch.FGLang</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>We want: <code><a href="../base-4.10.1.0/Data-Functor.html#t:Functor">Functor</a></code> isomorphisms between these compositions of <code>F</code> and <code>G</code>:</p><pre> F(G(A))    -- we have a composition of functors
 F(F(G(A))) -- we partition the outer functor into pieces such that `unique partition (xs :: f (g a))` is true for our partition (if it exists, of course, that's where graph coloring comes in)
 F(G(F(A))) -- we push the partition into the inner functor, resulting in the connected (f (g a)) pieces being joined along their partitions.
</pre><p>In other words, it pulls the partition up to <code>F</code>'s level while pushing the structure of <code>F</code> down into <code>G</code>.
 The structure of <code>F</code> is available to <code>G</code> in slices (local by definition of the partition).</p><p>Note: all of these operations are invertible since we have unique partitions (though I think I'm missing some constraints?)</p><p>Additionally, the functors which this works for are local functors and computers _really_ like computational and data locality.
 Computational locality makes stream and massively parallel processing a breeze (case in point, the line-by-line parser I just wrote).</p><pre>  f :: X -&gt; Y =&gt; F(G(f)) :: F(G(X)) -&gt; F(G(Y))
</pre><p>That is, we want three natural transformations that are also isomorphisms between those compositions:</p><pre>  X :: C =&gt; eta_1(X) :: F(G(X)) -&gt; F(F(G(X))) :: C -&gt; C
  X :: C =&gt; eta_2(X) :: F(F(G(X))) -&gt; F(G(F(X))) :: C -&gt; C
  X :: C =&gt; eta_3(X) :: F(G(F(X))) -&gt; F(G(X)) :: C -&gt; C

  f :: X -&gt; Y :: C -&gt; C =&gt; eta_1(Y) . F(G(f)) = F(F(G(f))) . eta_1(X) :: F(G(X)) -&gt; F(F(G(Y))) :: C -&gt; C
  f :: X -&gt; Y :: C -&gt; C =&gt; eta_2(Y) . F(F(G(f))) = F(G(F(f))) . eta_2(X) :: F(F(G(X))) -&gt; F(G(F(Y))) :: C -&gt; C
  f :: X -&gt; Y :: C -&gt; C =&gt; eta_3(Y) . F(G(F(f))) = F(G(f)) . eta_3(X) :: F(G(F(X))) -&gt; F(G(Y)) :: C -&gt; C
</pre><p>We require these natural transformations to be bijections.</p><p>Misc. notes:</p><pre>h = f . h
h -&gt; f . h
h . g -&gt; h . g . f

f . h -&gt; h
h . g . f -&gt; h . g
</pre><pre> a pusher is guaranteed to push all it can over at once only if f is pointed and props hold.

 (i think) a copusher .. iff f is copointed and props hold
</pre><p>This effectively reduces <code>(f+gf*)</code> to <code>(fgf?)</code>. Is this reduction a pushing of compositions of <code>f</code> inside?</p><pre>  yeah, what I've done is taken the set of words in the language, partitioned them on their compositions without all of the (return)'s, and given you a view inside that newly partitioned language.
  Really, really cool. I think this means that the partition interpretation mught be precise.
  ok, so let's say we have a partition (p), which is a natual transformation from (g a) to some index functor.
    ahh, since p is an endofunctor, we only really need to have <code><a href="Scratch-FGLang.html#v:p">p</a></code> be an injection, and can make the index functor `f (g a)`
    really, we want the maximal (f (g a) -&gt; f (f (g a))) function such that pushing over pushes everything that can be over,
    we want to partition on (g a) such that we can reconstruct the structure of a connected component of g's in the partition inside of (g a)
 in other words, we need to ensure that the lines of the connected components do not cross the lines of what parts of <code>f</code> can be passed through <code>g</code>.
   first of all, in what sense does <code>f</code> form a graph, that we can accurrately describe what parts are adjacent?
     if <code>f</code> is pointed, then those components that cannot pass through are those such that: (push == fmap (fmap return) :: f . g -&gt; f . g . f)
     so we get a relation `can pass through(To) :: f g (a)`, where push is non-trivial
     we can also use (return) to specify that everything has passed through. we then can know: has anything passed through on <code>x</code> step, has everything passed through, really everything about what has passed through when
     p  :: g a -&gt; b
     p' :: f (g a) -&gt; b
     p' (return x) = p x
     extractor :: f b -&gt; maybe b
     p' = extractor . fmap p
     extractor (p <a href="$">$</a> return x) = p x
     ahh, we can have a natural extractor, y -&gt; { x | f associates x with y} :: f (g a) -&gt; {g a}
     so we require that. y -&gt; forall (x :: g a). f x == y =&gt; p x :: f (g a) -&gt; Bool (the property maps all of the elements of the preimage to the same value)
      and that holds forall (f (g a)) <code><a href="../base-4.10.1.0/Data-Foldable.html#v:elem">elem</a></code> (f (f (g a)))
      which also has a most general format of: y -&gt; { x | f associates x with y &amp;&amp; x <code><a href="../base-4.10.1.0/Data-Foldable.html#v:elem">elem</a></code> y}
      which I believe is both a valid inclusion and the most general inclusion
      valid inclusion: (x <code><a href="../base-4.10.1.0/Data-Foldable.html#v:elem">elem</a></code> return x), x <code><a href="../base-4.10.1.0/Data-Foldable.html#v:elem">elem</a></code> y =&gt; forall f. f x <code><a href="../base-4.10.1.0/Data-Foldable.html#v:elem">elem</a></code> fmap f y
        if this is all we need then we get it from (x <code><a href="../base-4.10.1.0/Data-Foldable.html#v:elem">elem</a></code> return x) and f being a functor [else hi]
          (all singleton (== return x) preimages for <code>f</code> implies f == const | identity?)
     and this predicate has: fmap pred . partition == fmap (const True) . partition
     and the partition is preserved by crossing <code>g</code>?
</pre><p>Alright, we want to classify each operation as being idempotent, and find what results we have.</p><p>We already have that all being idempotent implies that <code>f</code> is pointed and the second operation is equivalent to fmapping the pointing function up to the difference in types.</p><p>Since the category probably doesn't have bool (if that even makes sense), if it's the unit category then the partition is trivial, else it holds for mapping any pair of elements of C to (False, True)</p><p>Really, it works either way, so we can just skip to it:</p><pre> the checker does (if pred then xx else yy) and then we have:
 fmap checker . partition == fmap (const xx) . partition
</pre><p>Question: is the <code>checker</code> function a valid function in the category? I'm not sure.
 We may have to fall back to a fold.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Lang">Lang</a> = <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Expr">Expr</a> = <a href="../containers-0.5.10.2/Data-Sequence-Internal.html#t:Seq">Seq</a> <a href="Scratch-FGLang.html#t:Lang">Lang</a></li><li class="src short"><a href="#v:parse">parse</a> :: <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Scratch-FGLang.html#t:Expr">Expr</a></li><li class="src short"><a href="#v:p">p</a> :: <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Scratch-FGLang.html#t:Expr">Expr</a></li><li class="src short"><a href="#v:base1">base1</a> :: <a href="Scratch-FGLang.html#t:Expr">Expr</a></li><li class="src short"><a href="#v:base2">base2</a> :: <a href="Scratch-FGLang.html#t:Expr">Expr</a></li><li class="src short"><a href="#v:base3">base3</a> :: <a href="Scratch-FGLang.html#t:Expr">Expr</a></li><li class="src short"><a href="#v:bases">bases</a> :: <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a></li><li class="src short"><a href="#v:allReplacements">allReplacements</a> :: <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a></li><li class="src short"><a href="#v:r0">r0</a> :: <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a></li><li class="src short"><a href="#v:nest">nest</a> :: <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a> -&gt; (a -&gt; a) -&gt; a -&gt; a</li><li class="src short"><a href="#v:rs">rs</a> :: <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a></li><li class="src short"><a href="#v:rsn">rsn</a> :: <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a></li><li class="src short"><a href="#v:ex">ex</a> :: <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a></li><li class="src short"><a href="#v:exn">exn</a> :: <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a></li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Lang" class="def">Lang</a> = <a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Scratch.FGLang.html#Lang" class="link">Source</a> <a href="#t:Lang" class="selflink">#</a></p><div class="doc"><p>Just <code><a href="../base-4.10.1.0/Data-Bool.html#t:Bool">Bool</a></code>, tried making it its own data type</p><pre>  f . g     = f . f . g
  f . f . g = f . g . f
  f . g     = f . g . f

  (f . g) . f = (f . g . f) . f
</pre><pre>data Lang = F | G deriving (Eq, Ord, Show)

FG = FFG = FGF

instance Hashable Lang where
  hashWithSalt = hashUsing (== F)
</pre></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Expr" class="def">Expr</a> = <a href="../containers-0.5.10.2/Data-Sequence-Internal.html#t:Seq">Seq</a> <a href="Scratch-FGLang.html#t:Lang">Lang</a> <a href="src/Scratch.FGLang.html#Expr" class="link">Source</a> <a href="#t:Expr" class="selflink">#</a></p><div class="doc"><p>An expression is a sqeuence of <code><a href="Scratch-FGLang.html#t:Lang">Lang</a></code>s</p></div></div><div class="top"><p class="src"><a id="v:parse" class="def">parse</a> :: <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#parse" class="link">Source</a> <a href="#v:parse" class="selflink">#</a></p><div class="doc"><p>Parse an <code><a href="Scratch-FGLang.html#t:Expr">Expr</a></code>.</p><p>For example:</p><pre> &#955;&gt; parse <a href="GFGFGGFFGF.html">GFGFGGFFGF</a>
 fromList [True,False,True,False,True,True,False,False,True,False]
</pre></div></div><div class="top"><p class="src"><a id="v:p" class="def">p</a> :: <a href="../base-4.10.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#p" class="link">Source</a> <a href="#v:p" class="selflink">#</a></p><div class="doc"><p>Abbreviation for <code><a href="Scratch-FGLang.html#v:parse">parse</a></code></p></div></div><div class="top"><p class="src"><a id="v:base1" class="def">base1</a> :: <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#base1" class="link">Source</a> <a href="#v:base1" class="selflink">#</a></p><div class="doc"><p>First base</p><pre>[F, G]
</pre></div></div><div class="top"><p class="src"><a id="v:base2" class="def">base2</a> :: <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#base2" class="link">Source</a> <a href="#v:base2" class="selflink">#</a></p><div class="doc"><p>Second base</p><pre>[F, F, G]
</pre></div></div><div class="top"><p class="src"><a id="v:base3" class="def">base3</a> :: <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#base3" class="link">Source</a> <a href="#v:base3" class="selflink">#</a></p><div class="doc"><p>Third base</p><pre>[F, G, F]
</pre></div></div><div class="top"><p class="src"><a id="v:bases" class="def">bases</a> :: <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#bases" class="link">Source</a> <a href="#v:bases" class="selflink">#</a></p><div class="doc"><p><code><a href="Scratch-FGLang.html#v:base1">base1</a></code>, <code><a href="Scratch-FGLang.html#v:base2">base2</a></code>, and <code><a href="Scratch-FGLang.html#v:base3">base3</a></code></p><p>The language seeded by: <code>FG</code>, <code>FFG</code>, <code>FGF</code> with the rules: <code>FG == FFG == FGF</code>
   is equivalent to the regular language generated by the expression: <code>(F+)G(F?)</code>.</p><p>We can use this to provide an isomorphism with a more combinatorically friendly type (Nat, Bool)</p><pre>  gen :: Nat -&gt; Bool -&gt; Lang
  gen n False = replicate n <code>F</code> &lt;&gt; <a href="FG.html">FG</a>
  gen n _    = replicate n <code>F</code> &lt;&gt; <a href="FGF.html">FGF</a>

  unGen :: Lang -&gt; (Nat, Bool)
  unGen xs = (length (takeWhile (== <code>F</code>) xs) - 1, last xs == <code>F</code>)
</pre><p>We can also redefine the language as:
 <code>
   base term:
     FG
   replacement rules:
     s<em>G$</em>GF/   --____ toggle ending F
     s<em>F$</em><em>     --</em>
     s<em>^FF</em>F<em>   --____ can always prepend an F, can remove an F unless it matches </em>^FG/
     s<em>^</em>F<em>     --</em>
 </code></p><p>The lines are natural isomorphisms and the <code><a href="../base-4.10.1.0/Data-Function.html#v:.">.</a></code> is functor composition</p><pre>
            (f . g)
              / 
             /   
            /     
           /       
          /         
  f . (f . g) --- (f . g) . f
</pre><p>I really, really like this diagram.
 It completely explains the structure of this language.</p></div></div><div class="top"><p class="src"><a id="v:allReplacements" class="def">allReplacements</a> :: <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#allReplacements" class="link">Source</a> <a href="#v:allReplacements" class="selflink">#</a></p><div class="doc"><p>All replacements of an expression.</p><p>Uses <code><a href="Data-HashSet-Utils.html#v:replacements">replacements</a></code> on <code><a href="Scratch-FGLang.html#v:base1">base1</a></code>, <code><a href="Scratch-FGLang.html#v:base2">base2</a></code>, <code><a href="Scratch-FGLang.html#v:base3">base3</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:r0" class="def">r0</a> :: <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#r0" class="link">Source</a> <a href="#v:r0" class="selflink">#</a></p><div class="doc"><p>Alias for <code><a href="Scratch-FGLang.html#v:allReplacements">allReplacements</a></code></p><p>See below for example printing function implementation (not working):</p><pre>s :: Set Expr -&gt; IO ()
s x = (mapM_ (y _) -&gt; putStrLn . fmap (z -&gt; if z then <code>F</code> else <code>G</code>) . (toList :: Expr -&gt; [Lang]) $ y) . reverse . sort . fromList . S.toList) x &gt;&gt; putStrLn []
</pre></div></div><div class="top"><p class="src"><a id="v:nest" class="def">nest</a> :: <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a> -&gt; (a -&gt; a) -&gt; a -&gt; a <a href="src/Scratch.FGLang.html#nest" class="link">Source</a> <a href="#v:nest" class="selflink">#</a></p><div class="doc"><p>Nest a function on a value some number of times</p></div></div><div class="top"><p class="src"><a id="v:rs" class="def">rs</a> :: <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#rs" class="link">Source</a> <a href="#v:rs" class="selflink">#</a></p><div class="doc"><p>Iterate on a <code><a href="Data-HashSet-Utils.html#t:Set">Set</a></code> of expressions with <code><a href="Scratch-FGLang.html#v:allReplacements">allReplacements</a></code></p></div></div><div class="top"><p class="src"><a id="v:rsn" class="def">rsn</a> :: <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#rsn" class="link">Source</a> <a href="#v:rsn" class="selflink">#</a></p><div class="doc"><p><code><a href="Scratch-FGLang.html#v:rs">rs</a></code>, the given number of times</p></div></div><div class="top"><p class="src"><a id="v:ex" class="def">ex</a> :: <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#ex" class="link">Source</a> <a href="#v:ex" class="selflink">#</a></p><div class="doc"><p>Iterate as in <code><a href="Scratch-FGLang.html#v:rs">rs</a></code>, but keep already seen values</p></div></div><div class="top"><p class="src"><a id="v:exn" class="def">exn</a> :: <a href="../base-4.10.1.0/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> -&gt; <a href="Data-HashSet-Utils.html#t:Set">Set</a> <a href="Scratch-FGLang.html#t:Expr">Expr</a> <a href="src/Scratch.FGLang.html#exn" class="link">Source</a> <a href="#v:exn" class="selflink">#</a></p><div class="doc"><p><code><a href="Scratch-FGLang.html#v:ex">ex</a></code>, the given number of times</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.18.1</p></div></body></html>